---
layout: post
title: 旧文整理：MinGW写的简易记事本 Ver0.02
tags: [MinGW,Notepad,Windows]
---
<h2>{{ page.title }}</h2>
MinGW下编写的记事本，也可以认为是API编程，SDK编程什么的。反正是没使用MFC……我不是科班出身的，这些名词界限搞不懂……
使用-mwindows参数编译……<br><pre class="brush: cpp; gutter: true">#define _UNICODE /* for std c */<br>#define UNICODE /* for windows api */<br><br>#include &lt;stdio.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;tchar.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;windowsx.h&gt;<br>#include &lt;windows.h&gt;<br>#include &lt;commdlg.h&gt;<br>#include &lt;commctrl.h&gt;<br><br>/*============================================================================*/<br>/*DEBUG(Add the define below if need) */<br>#define DEBUG<br>VOID DEBUG_Output(TCHAR* lpszFormat, ...);<br><br>/*============================================================================*/<br>/*CTRL ID */<br>#define CTRL_ID_STATIC (0)<br>#define CTRL_ID_EDIT_TEXT (1)<br>#define CTRL_ID_EDIT_INPUT (2)<br>#define CTRL_ID_EDIT_REPLACE (3)<br>#define CTRL_ID_BTN_INPUT (4)<br>#define CTRL_ID_BTN_CANCEL (5)<br>#define CTRL_ID_STATUSBAR (6)<br><br>/*============================================================================*/<br>/*MENU ID */<br>#define MENU_ID_NEW (10)<br>#define MENU_ID_OPEN (11)<br>#define MENU_ID_SAVE (12)<br>#define MENU_ID_SAVEAS (13)<br>#define MENU_ID_EXIT (14)<br><br>#define MENU_ID_UNDO (20)<br>#define MENU_ID_COPY (21)<br>#define MENU_ID_PASTE (22)<br>#define MENU_ID_CUT (23)<br>#define MENU_ID_DEL (24)<br>#define MENU_ID_SELALL (25)<br>#define MENU_ID_GOTO (26)<br>#define MENU_ID_FIND (27)<br>#define MENU_ID_NEXT (28)<br>#define MENU_ID_REPLACE (29)<br>#define MENU_ID_DATE (30)<br><br>#define MENU_ID_WRET (40)<br><br>#define MENU_ID_ABOUT (50)<br><br>/*============================================================================*/<br>/* CONST DEFINE */<br>#define MAX_STRING (256)<br><br>/* The return value of the most APIs is limited in integer. */<br>/* So limit the max edit characters'' number to 65535 */<br>/* If need to deal with any files larger than 65535 bytes , */<br>/* Some complex arithmetics (i.e. column number) should to be added. */<br>#define MAX_EDIT (65535U)<br><br>/* One line''s one used for Goto and Find , two used for Repalce */<br>#define FLAG_INPUTDLG_ONELINE (0)<br>#define FLAG_INPUTDLG_TWOLINE (1)<br><br>#define FLAG_INPUTFLG_NONE (0)<br>#define FLAG_INPUTFLG_GOTO (1)<br>#define FLAG_INPUTFLG_FIND (2)<br>#define FLAG_INPUTFLG_REPLACE (3)<br><br>#ifdef UNICODE<br>#define SN_CF_TEXT (CF_UNICODETEXT)<br>#else<br>#define SN_CF_TEXT (CF_TEXT)<br>#endif<br><br>/*============================================================================*/<br>/* TYPEDEF */<br>typedef struct{<br>UINT nID;<br>TCHAR *pText;<br>}MenuString_st;<br><br>/*============================================================================*/<br>/* CONST VARIABLE */<br>const TCHAR *szClassName = TEXT("MySimpleNotepad");<br>const TCHAR *szCaptionMain = TEXT("Simple Notepad Ver0.02");<br>const TCHAR *szFind = TEXT("Find:");<br>const TCHAR *szReplace = TEXT("Replace:");<br>const TCHAR *szGoto = TEXT("Goto:");<br>const TCHAR *szError = TEXT("Error");<br>const TCHAR *szSaveModify = TEXT("Save the modify?");<br><br>const MenuString_st stMenuString[]={<br>{MENU_ID_NEW ,TEXT("New a file.")},<br>{MENU_ID_OPEN ,TEXT("Open a file.")},<br>{MENU_ID_SAVE ,TEXT("Save the file.")},<br>{MENU_ID_SAVEAS ,TEXT("Save the texts to an other file.")}<br>};<br><br>/*============================================================================*/<br>/* VARIABLE */<br>HANDLE hInstance;<br>HWND hWinMain;<br>HWND hInputDlg;<br>HWND hWinStatus;<br><br>INT nInputDlgSts;<br><br>BOOL bUndo;<br>BOOL bWantReturn;<br><br>TCHAR cCrtFile[MAX_PATH];<br>TCHAR cInputEdit[MAX_STRING];<br><br>/*============================================================================*/<br>/* PROTOTYPE */<br>INT _WinMain(VOID);<br><br>LRESULT CALLBACK _ProcWinMain(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam);<br>LRESULT CALLBACK _ProcInputDlg(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam);<br>BOOL _PreTranslateMessage(MSG* pMsg);<br><br>HWND CreateEdit(DWORD dwStyle);<br>HWND CreatInputDlg(TCHAR* pTitle,INT nFlag);<br>HWND CreateStatusBar(VOID);<br>HMENU CreateMainMenu(VOID);<br>HACCEL CreateAccelerator(VOID);<br><br>VOID OnSetFocus(VOID);<br>VOID OnSize(VOID);<br>VOID OnAbout(VOID);<br>VOID OnQuit(VOID);<br>VOID OnNew(VOID);<br>VOID OnOpen(VOID);<br>VOID OnSave(INT nFlag);<br>VOID OnUndo(VOID);<br>VOID OnCopy(VOID);<br>VOID OnPaste(VOID);<br>VOID OnCut(VOID);<br>VOID OnDel(VOID);<br>VOID OnSelAll(VOID);<br>VOID OnWantReturn(VOID);<br>VOID OnGoto(INT nFlag);<br>VOID OnFind(INT nFlag);<br>VOID OnReplace(INT nFlag);<br>VOID OnDateTime(VOID);<br>VOID OnMenuSelect(UINT);<br><br>VOID OnEditCurMoved(VOID);<br><br>VOID OnInputDlgClose(HWND hWnd);<br>VOID OnInputDlgTab(VOID);<br><br>VOID ModifyWinTitle(VOID);<br>VOID OpenGivenFile(TCHAR *pFile);<br>BOOL Find(TCHAR tcFind[],DWORD *dwStart,DWORD *dwEnd);<br>BOOL Edit_GetSelText(HWND hWnd,TCHAR *pBuffer,INT nLenMax);<br><br>/*============================================================================*/<br>/* FUNCTION */<br>VOID ModifyWinTitle(VOID)<br>{<br>TCHAR *cTitle;<br>INT nSize = MAX_PATH + _tcslen(szCaptionMain)<br>+ 3 /* For the length of " - " */<br>+ 1; /* For the length of "*" */<br>cTitle = malloc(nSize * sizeof(TCHAR));<br>ZeroMemory(cTitle,nSize);<br>_stprintf(cTitle,TEXT("%s%s - %s"),<br>(_tcslen(cCrtFile)==0)?TEXT("Untitled"):cCrtFile,<br>(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))?TEXT("*"):TEXT("")),<br>szCaptionMain);<br>SetWindowText(hWinMain,cTitle);<br>free(cTitle);<br>}<br><br>VOID OnSetFocus(VOID)<br>{<br>if(GetFocus() != GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT)){<br>SetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>}<br>}<br><br>VOID OnSize(VOID)<br>{<br>RECT stRect;<br>RECT stRectSts;<br><br>/* Keep the status at the bottom of the dlg */<br>MoveWindow(hWinStatus,0,0,0,0,TRUE);<br><br>/* Adjust the size of the edit ctrl */<br>GetClientRect(hWinMain,&amp;stRect);<br>GetWindowRect(hWinStatus,&amp;stRectSts);<br><br>MoveWindow(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),/<br>0,0,<br>stRect.right-stRect.left,<br>stRect.bottom-stRect.top-stRectSts.bottom+stRectSts.top,<br>FALSE);<br><br>/* Adjust the width of each part in the status dynamically */<br>DWORD dwStatusWidth[] = {0,-1};<br>dwStatusWidth[0] = stRect.right/3*2;<br>SendMessage(hWinStatus,SB_SETPARTS,2,(LPARAM)dwStatusWidth);<br>}<br><br>VOID OnAbout(VOID)<br>{<br>MessageBox(NULL,TEXT("Copyleft (C) 2010/n/nCompiler:MinGW-5.1.6[gcc version 3.4.5 (mingw-vista special r3) (with option -mwindows)]/n/nComment:The max file size is 65535 Bytes."),TEXT("About..."),MB_OK);<br>}<br><br>VOID OnQuit(VOID)<br>{<br>if(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))){<br>INT nID = MessageBox(NULL,szSaveModify,szCaptionMain,MB_OKCANCEL);<br>if(IDOK == nID){<br>OnSave(0);<br>}<br>}<br>else{<br>}<br>DestroyWindow(hWinMain);<br>PostQuitMessage(0);<br>}<br><br>VOID OnNew(VOID)<br>{<br>if(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))){<br>INT nID = MessageBox(NULL,szSaveModify,szCaptionMain,MB_OKCANCEL);<br>if(IDOK == nID){<br>OnSave(0);<br>}<br>}<br>else{<br>}<br>SetWindowText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),TEXT(""));<br>}<br><br>VOID OpenGivenFile(TCHAR *pFile)<br>{<br>HANDLE hFile;<br>DWORD dwSize,Num;<br>CHAR *lpMultiByteStr;<br>TCHAR *lpWideCharStr;<br><br>hFile=CreateFile(pFile,GENERIC_READ,0,NULL,OPEN_ALWAYS,<br>FILE_ATTRIBUTE_NORMAL,NULL);<br>if(INVALID_HANDLE_VALUE!= hFile )<br>{<br>SetFilePointer(hFile,0,0,FILE_BEGIN);<br><br>dwSize = GetFileSize(hFile,NULL);<br><br>lpMultiByteStr = malloc((dwSize+1) * sizeof(CHAR)); /*NOT sure if need to reserve a byte for ''/0'' */<br>ZeroMemory(lpMultiByteStr,(dwSize+1) * sizeof(CHAR));<br><br>#ifdef UNICODE<br>/* The text file is based on ansi , but the edit ctrl is based on unicode. */<br>/* So need to convert the ansi strings to unicode format. */<br>lpWideCharStr = malloc((dwSize+1) * sizeof(TCHAR)); /*NOT sure if need to reserve a byte for ''/0'' */<br>ZeroMemory(lpWideCharStr,(dwSize+1) * sizeof(TCHAR));<br><br>ReadFile(hFile,lpMultiByteStr,dwSize,&amp;Num,NULL);<br><br>MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,<br>lpMultiByteStr,(dwSize) * sizeof(CHAR),<br>lpWideCharStr,(dwSize) * sizeof(TCHAR));<br>#else<br>lpWideCharStr = lpMultiByteStr;<br>#endif<br><br>Edit_SetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),lpWideCharStr);<br><br>free(lpMultiByteStr);<br>#ifdef UNICODE<br>free(lpWideCharStr);<br>#endif<br>CloseHandle(hFile);<br>}<br><br>ModifyWinTitle();<br><br>SetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>}<br><br>VOID OnOpen(VOID)<br>{<br>if(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))){<br>INT nID = MessageBox(NULL,szSaveModify,szCaptionMain,MB_OKCANCEL);<br>if(IDOK == nID){<br>OnSave(0);<br>}<br>}<br>else{<br>}<br><br>TCHAR *cFilter = TEXT("Non-Unicode Text File(*.txt)/0*.TXT/0");<br>OPENFILENAME ofFile;<br><br>memset(&amp;ofFile,0,sizeof(OPENFILENAME));<br>ofFile.lStructSize = sizeof(OPENFILENAME);<br>ofFile.hwndOwner = hWinMain;<br>ofFile.hInstance = hInstance;<br>ofFile.lpstrFilter = cFilter;<br>ofFile.lpstrTitle = TEXT("Open");<br>ofFile.lpstrFile = cCrtFile;<br>ofFile.nMaxFile = MAX_PATH;<br>ofFile.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;<br><br>if(GetOpenFileName(&amp;ofFile)){<br>OpenGivenFile(cCrtFile);<br>}<br><br>}<br><br>VOID OnSave(INT nFlag)<br>{<br>if((nFlag) || (_tcslen(cCrtFile)==0)){<br>TCHAR *cFilter = TEXT("Non-Unicode Text File(*.txt)/0*.TXT/0");<br>OPENFILENAME ofFile;<br><br>memset(&amp;ofFile,0,sizeof(OPENFILENAME));<br>ofFile.lStructSize = sizeof(OPENFILENAME);<br>ofFile.hwndOwner = hWinMain;<br>ofFile.hInstance = hInstance;<br>ofFile.lpstrFilter = cFilter;<br>ofFile.lpstrTitle = TEXT("Save As");<br>ofFile.lpstrFile = cCrtFile;<br>ofFile.nMaxFile = MAX_PATH;<br>ofFile.lpstrDefExt = TEXT(".txt");<br>ofFile.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;<br><br>GetSaveFileName(&amp;ofFile);<br>}<br>else{<br>}<br><br>if(_tcslen(cCrtFile) != 0){<br>HANDLE hFile;<br>DWORD dwSize,Num;<br>CHAR *lpMultiByteStr;<br>TCHAR *lpWideCharStr;<br>hFile=CreateFile(cCrtFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,<br>FILE_ATTRIBUTE_NORMAL,NULL);<br>if(INVALID_HANDLE_VALUE!= hFile )<br>{<br><br>SetFilePointer(hFile,0,0,FILE_BEGIN);<br><br>dwSize = Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))+1;<br><br>lpWideCharStr = malloc((dwSize) * sizeof(TCHAR));<br>ZeroMemory(lpWideCharStr,(dwSize) * sizeof(TCHAR));<br><br>#ifdef UNICODE<br>/* The text file is based on ansi , but the edit ctrl is based on unicode. */<br>/* So need to convert the unicode strings to ansi format. */<br>lpMultiByteStr = malloc((dwSize) * sizeof(CHAR));<br>ZeroMemory(lpMultiByteStr,(dwSize) * sizeof(CHAR));<br><br>Edit_GetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),lpWideCharStr,dwSize);<br><br>WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK,<br>lpWideCharStr,dwSize * sizeof(TCHAR),<br>lpMultiByteStr,dwSize * sizeof(CHAR),<br>NULL,NULL);<br>#else<br>lpMultiByteStr = lpWideCharStr;<br>#endif<br><br>WriteFile(hFile,lpMultiByteStr,dwSize,&amp;Num,NULL);<br><br>#ifdef UNICODE<br>free(lpMultiByteStr);<br>#endif<br>free(lpWideCharStr);<br><br>CloseHandle(hFile);<br><br>Edit_SetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),FALSE);<br>}<br>}<br><br>ModifyWinTitle();<br>}<br><br>VOID OnUndo(VOID)<br>{<br>Edit_Undo(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>}<br><br>VOID OnCopy(VOID)<br>{<br>TCHAR * pText;<br>HANDLE hGlobal;<br>PTSTR pGlobal ;<br>DWORD dwGetSel;<br>DWORD dwEditLen;<br><br>dwGetSel = Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>dwEditLen = Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br><br>pText = malloc((dwEditLen+1) * sizeof(TCHAR));<br>Edit_GetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),pText,dwEditLen);<br><br>hGlobal = GlobalAlloc (GHND | GMEM_SHARE, (HIWORD(dwGetSel) - LOWORD(dwGetSel) + 1) * sizeof (TCHAR)) ;<br>pGlobal = GlobalLock (hGlobal) ;<br>_tcsncpy (pGlobal, &amp;pText[LOWORD(dwGetSel)],HIWORD(dwGetSel) - LOWORD(dwGetSel)) ;<br>GlobalUnlock (hGlobal) ;<br>OpenClipboard (hWinMain) ;<br>EmptyClipboard () ;<br>SetClipboardData (SN_CF_TEXT, hGlobal) ;<br>CloseClipboard () ;<br>}<br><br>VOID OnPaste(VOID)<br>{<br>HANDLE hGlobal;<br>PTSTR pGlobal ;<br>OpenClipboard (hWinMain) ;<br>if (IsClipboardFormatAvailable (SN_CF_TEXT)) {<br>hGlobal = GetClipboardData (SN_CF_TEXT);<br>pGlobal = GlobalLock (hGlobal) ;<br>Edit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),pGlobal);<br>GlobalUnlock (hGlobal) ;<br>}<br>CloseClipboard () ;<br><br>}<br><br>VOID OnCut(VOID)<br>{<br>OnCopy();<br>OnDel();<br>}<br><br>VOID OnDel(VOID)<br>{<br>Edit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),TEXT(""));<br>}<br><br>VOID OnSelAll(VOID)<br>{<br>Edit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),<br>0,<br>Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT)));<br>}<br><br>VOID OnWantReturn(VOID)<br>{<br>DWORD dwStyle;<br><br>bWantReturn = !bWantReturn;<br><br>dwStyle = GetWindowLong(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),GWL_STYLE);<br>if(bWantReturn){<br>dwStyle &amp;= (~(ES_AUTOHSCROLL|WS_HSCROLL)) ;<br>}<br>else{<br>dwStyle |= (ES_AUTOHSCROLL)|(WS_HSCROLL) ;<br>}<br><br>/* Cound not change the style after an edit-ctrl-created. */<br>/* So need to re-create the edit ctrl for style changing. */<br>DestroyWindow(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>CreateEdit(dwStyle);<br>if(_tcslen(cCrtFile) != 0){<br>OpenGivenFile(cCrtFile);<br>}<br>}<br><br>VOID OnDateTime(VOID)<br>{<br>time_t t;<br>struct tm *newtime;<br>TCHAR tcDate[MAX_STRING];<br><br>time(&amp;t);<br>newtime = localtime( &amp;t );<br>_stprintf(tcDate,TEXT("%02d:%02d %04d-%02d-%02d"),/<br>newtime-&gt;tm_hour,newtime-&gt;tm_min,/<br>newtime-&gt;tm_year+1900,newtime-&gt;tm_mon+1, newtime-&gt;tm_mday<br>);<br>Edit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),tcDate);<br>}<br><br>VOID OnEditCurMoved(VOID)<br>{<br>INT nRow,nCol;<br>TCHAR tcBuff[MAX_STRING];<br><br>/* Use EM_LINEFROMCHAR to get the current line. */<br>nRow = Edit_LineFromChar(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),-1);<br>/* We could get the index of the current charactor in an edit ctrl (A)<br>and the count of the charactors till the last line (B)<br>So the value of A-B would be the column.*/<br>nCol = HIWORD(Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))) - /<br>Edit_LineIndex(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),-1);<br>_stprintf(tcBuff,TEXT("Ln %d, Col %d"),nRow+1,nCol+1);<br><br>/* Used to update the Line and column info in status bar. */<br>SendMessage(hWinStatus,SB_SETTEXT,1,(LPARAM)tcBuff);<br><br>}<br><br>VOID OnMenuSelect(UINT uItem)<br>{<br>INT n,nIdCnt = sizeof(stMenuString)/sizeof(stMenuString[0]);<br><br>/* Used to update the menu hint info in status bar. */<br>for(n=0;n&lt;nIdCnt;n++){<br>if(uItem == stMenuString[n].nID){<br>SendMessage(hWinStatus,SB_SETTEXT,0,(LPARAM)stMenuString[n].pText);<br>break;<br>}<br>}<br><br>if(n &gt;= nIdCnt){<br>SendMessage(hWinStatus,SB_SETTEXT,0,(LPARAM)TEXT(""));<br>}<br>}<br><br>LRESULT CALLBACK _ProcWinMain(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam)<br>{<br>if(WM_SIZE == uMsg){<br>OnSize();<br>}<br>else if(WM_CLOSE == uMsg){<br>OnQuit();<br>}<br>else if(WM_SETFOCUS == uMsg){<br>OnSetFocus();<br>}<br>else if(WM_INITMENUPOPUP == uMsg){<br>//if((UINT) LOWORD(lParam) == 1){<br>BOOL bEnable;<br>bEnable = (Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT)) != 0) ? MF_ENABLED : MF_GRAYED ;<br>EnableMenuItem ((HMENU) wParam, MENU_ID_UNDO, bUndo ? MF_ENABLED : MF_GRAYED) ;<br>EnableMenuItem ((HMENU) wParam, MENU_ID_PASTE, IsClipboardFormatAvailable (SN_CF_TEXT) ? MF_ENABLED : MF_GRAYED) ;<br>EnableMenuItem ((HMENU) wParam, MENU_ID_CUT, bEnable) ;<br>EnableMenuItem ((HMENU) wParam, MENU_ID_COPY, bEnable) ;<br>EnableMenuItem ((HMENU) wParam, MENU_ID_DEL, bEnable) ;<br>//}<br><br>CheckMenuItem((HMENU) wParam,MENU_ID_WRET , bWantReturn?MF_CHECKED:MF_UNCHECKED);<br>}<br>else if(WM_MENUSELECT == uMsg){<br>OnMenuSelect((UINT) LOWORD(wParam));<br>}<br>else if(WM_DROPFILES == uMsg){<br>TCHAR lpszFileName[MAX_PATH];<br>DragQueryFile((HANDLE)wParam, 0, lpszFileName, MAX_PATH);<br>OpenGivenFile(lpszFileName);<br>_tcscpy(cCrtFile,lpszFileName);<br>}<br>else if((WM_COMMAND == uMsg)/*&amp;&amp;(HIWORD(wParam) == BN_CLICKED)*/){<br>WORD wNotifyCode = HIWORD(wParam); // notification code<br>WORD wID = LOWORD(wParam); // item, control, or accelerator identifier<br>HWND hCtl = (HWND) lParam; // handle of control<br>/*if(HIWORD(wParam) == BN_CLICKED){*/<br>switch(wID){<br>case MENU_ID_ABOUT:<br>OnAbout();<br>break;<br>case MENU_ID_EXIT:<br>OnQuit();<br>break;<br>case MENU_ID_NEW:<br>OnNew();<br>break;<br>case MENU_ID_OPEN:<br>OnOpen();<br>break;<br>case MENU_ID_SAVE:<br>OnSave(0);<br>break;<br>case MENU_ID_SAVEAS:<br>OnSave(1);<br>break;<br>case MENU_ID_UNDO:<br>OnUndo();<br>break;<br>case MENU_ID_COPY:<br>OnCopy();<br>break;<br>case MENU_ID_PASTE:<br>OnPaste();<br>break;<br>case MENU_ID_CUT:<br>OnCut();<br>break;<br>case MENU_ID_DEL:<br>OnDel();<br>break;<br>case MENU_ID_SELALL:<br>OnSelAll();<br>break;<br>case MENU_ID_WRET:<br>OnWantReturn();<br>break;<br>case MENU_ID_GOTO:<br>OnGoto(0);<br>break;<br>case MENU_ID_FIND:<br>OnFind(0);<br>break;<br>case MENU_ID_NEXT:<br>OnFind(1);<br>break;<br>case MENU_ID_REPLACE:<br>OnReplace(0);<br>break;<br>case MENU_ID_DATE:<br>OnDateTime();<br>break;<br>default:<br>DefWindowProc(hWnd,uMsg,wParam,lParam);<br>break;<br>}<br>/*}<br>else */if(EN_CHANGE == HIWORD(wParam)){<br>ModifyWinTitle();<br>bUndo = TRUE;<br>}<br>else{<br>DefWindowProc(hWnd,uMsg,wParam,lParam);<br>}<br><br>}<br>else{<br>DefWindowProc(hWnd,uMsg,wParam,lParam);<br>}<br><br>}<br><br>VOID OnGoto(INT nFlag)<br>{<br>INT nLine;<br>TCHAR cBuff[MAX_STRING];<br><br>if(0 == nFlag){<br>nInputDlgSts = FLAG_INPUTFLG_GOTO;<br>CreatInputDlg(TEXT("Goto:"),FLAG_INPUTDLG_ONELINE);<br>/* Set the current line number to default */<br>nLine = Edit_LineFromChar(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),-1) + 1;<br>_itot(nLine,cBuff,10);<br>Edit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cBuff);<br>}<br>else{<br>Edit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cInputEdit,MAX_STRING);<br>nLine = Edit_LineIndex(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),_ttoi(cInputEdit)-1);<br>Edit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),nLine,nLine);<br>SetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>}<br>}<br><br>BOOL Find(TCHAR tcFind[],DWORD *dwStart,DWORD *dwEnd)<br>{<br>DWORD dwSize,Num;<br>DWORD dwFindStart;<br>TCHAR *cBuffer;<br>BOOL bRet = FALSE;<br><br>dwSize = Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))+1;<br>cBuffer = malloc(dwSize * sizeof(TCHAR));<br>ZeroMemory(cBuffer,dwSize * sizeof(TCHAR));<br><br>Edit_GetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cBuffer,dwSize);<br><br>dwFindStart = Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>dwFindStart = HIWORD(dwFindStart);<br><br>if(dwFindStart &lt; dwSize){<br>TCHAR *pFound = _tcsstr(cBuffer+dwFindStart,tcFind);<br>if(pFound != NULL){<br>*dwStart = (DWORD)pFound - (DWORD)cBuffer;<br>*dwEnd = *dwStart + _tcslen(tcFind);<br>bRet = TRUE;<br>}<br>}<br>free(cBuffer);<br><br>return bRet;<br>}<br><br>BOOL Edit_GetSelText(HWND hWnd,TCHAR *pBuffer,INT nLenMax)<br>{<br>BOOL bRet = TRUE;<br><br>if(Edit_GetSel(hWnd) != 0){<br>TCHAR * pText;<br>DWORD dwGetSel;<br>DWORD dwEditLen;<br>DWORD dwSelLen;<br><br>dwGetSel = Edit_GetSel(hWnd);<br>dwEditLen = Edit_GetTextLength(hWnd);<br><br>pText = malloc((dwEditLen+1) * sizeof(TCHAR));<br>Edit_GetText(hWnd,pText,dwEditLen);<br><br>dwSelLen = HIWORD(dwGetSel) - LOWORD(dwGetSel);<br>dwSelLen = (nLenMax &gt; dwSelLen)?dwSelLen:nLenMax;<br><br>_tcsncpy (pBuffer, &amp;pText[LOWORD(dwGetSel)],dwSelLen) ;<br>}<br>else{<br>bRet = FALSE;<br>}<br>}<br><br>VOID OnFind(INT nFlag)<br>{<br>static TCHAR cString[MAX_STRING] = TEXT("");<br><br>DWORD dwStart,dwEnd;<br><br>if(0 == nFlag){<br>nInputDlgSts = FLAG_INPUTFLG_FIND;<br>CreatInputDlg(_T("Find:"),FLAG_INPUTDLG_ONELINE);<br>/* Set the selected text to default */<br>Edit_GetSelText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cString,MAX_STRING);<br>Edit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cString);<br>}<br>else{<br>if(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT)!=NULL){<br>Edit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cString,MAX_STRING);<br>}<br><br>BOOL bFind = Find(cString,&amp;dwStart,&amp;dwEnd);<br><br>if(bFind){<br>Edit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),dwStart,dwEnd);<br>}<br>else{<br>TCHAR tcCaution[MAX_STRING] = TEXT("Can not find /"");<br>_tcscat(tcCaution,cString);<br>_tcscat(tcCaution,TEXT("/"!"));<br>MessageBox(NULL,tcCaution,szCaptionMain,MB_OK);<br>}<br><br>}<br>}<br><br>VOID OnReplace(INT nFlag)<br>{<br>static TCHAR cFind[MAX_STRING] = TEXT("");<br>static TCHAR cReplace[MAX_STRING] = TEXT("");<br><br>DWORD dwStart,dwEnd;<br><br>if(0 == nFlag){<br>nInputDlgSts = FLAG_INPUTFLG_REPLACE;<br>CreatInputDlg(_T("Replace:"),FLAG_INPUTDLG_TWOLINE);<br>/* Set the selected text to default */<br>Edit_GetSelText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cFind,MAX_STRING);<br>Edit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cFind);<br>Edit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_REPLACE),cReplace);<br>}<br>else{<br>Edit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cFind,MAX_STRING);<br>Edit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_REPLACE),cReplace,MAX_STRING);<br><br>BOOL bFind = Find(cFind,&amp;dwStart,&amp;dwEnd);<br><br>if(bFind){<br>Edit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),dwStart,dwEnd);<br>Edit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cReplace);<br>}<br>else{<br>TCHAR tcCaution[MAX_STRING] = TEXT("Can not find /"");<br>_tcscat(tcCaution,cFind);<br>_tcscat(tcCaution,TEXT("/"!"));<br>MessageBox(NULL,tcCaution,szCaptionMain,MB_OK);<br>}<br><br>}<br>}<br><br>VOID OnInputDlgClose(HWND hWnd)<br>{<br>nInputDlgSts = FLAG_INPUTFLG_NONE;<br>DestroyWindow(hWnd);<br>hInputDlg = NULL;<br>SetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br>}<br><br>VOID OnInputDlgTab(VOID)<br>{<br>/* Tab order */<br>INT nIdTab[][2]={<br>{CTRL_ID_EDIT_INPUT ,CTRL_ID_EDIT_REPLACE },<br>{CTRL_ID_EDIT_REPLACE ,CTRL_ID_BTN_INPUT },<br>{CTRL_ID_BTN_INPUT ,CTRL_ID_BTN_CANCEL },<br>{CTRL_ID_BTN_CANCEL ,CTRL_ID_EDIT_INPUT }<br>};<br>INT n,nIdCnt = sizeof(nIdTab)/sizeof(nIdTab[0]);<br><br>INT nID = GetWindowLong(GetFocus(),GWL_ID);<br><br>for(n=0;n&lt;nIdCnt;n++){<br>if(nID == nIdTab[n][0]){<br>if(GetDlgItem(hInputDlg,nIdTab[n][1])!= NULL){<br>SetFocus(GetDlgItem(hInputDlg,nIdTab[n][1]));<br>break;<br>}<br>else{<br>nID = nIdTab[n][1];<br>}<br>}<br>}<br>}<br><br>LRESULT CALLBACK _ProcInputDlg(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam)<br>{<br>if(WM_PAINT == uMsg){<br>UpdateWindow(hWnd);<br>}<br>else if(WM_CLOSE == uMsg){<br>OnInputDlgClose(hWnd);<br>}<br>else if(WM_KEYDOWN == uMsg){<br>INT nVirtKey =(INT) wParam;<br><br>if(nVirtKey == VK_ESCAPE){<br>SendMessage(hWnd,WM_COMMAND,MAKELONG(CTRL_ID_BTN_CANCEL,BN_CLICKED),CTRL_ID_BTN_INPUT);<br>}<br>else if(nVirtKey == VK_RETURN){<br>SendMessage(hWnd,WM_COMMAND,MAKELONG(CTRL_ID_BTN_INPUT,BN_CLICKED),CTRL_ID_BTN_INPUT);<br>}<br>}<br>else if((WM_COMMAND == uMsg)/*&amp;&amp;(HIWORD(wParam) == BN_CLICKED)*/){<br>WORD wNotifyCode = HIWORD(wParam); // notification code<br>WORD wID = LOWORD(wParam); // item, control, or accelerator identifier<br>HWND hCtl = (HWND) lParam; // handle of control<br>switch(wID){<br>case CTRL_ID_BTN_INPUT:<br>if(FLAG_INPUTFLG_GOTO == nInputDlgSts){<br>OnGoto(1);<br>OnInputDlgClose(hWnd);<br>}<br>else if(FLAG_INPUTFLG_FIND == nInputDlgSts){<br>OnFind(1);<br>}<br>else if(FLAG_INPUTFLG_REPLACE == nInputDlgSts){<br>OnReplace(1);<br>}<br>else{<br>}<br>break;<br>case CTRL_ID_BTN_CANCEL:<br>OnInputDlgClose(hWnd);<br>break;<br>default:<br>DefWindowProc(hWnd,uMsg,wParam,lParam);<br>break;<br>}<br>}<br>else{<br>//DefWindowProc(hWnd,uMsg,wParam,lParam);<br>}<br><br>DefWindowProc(hWnd,uMsg,wParam,lParam);<br>}<br><br>HMENU CreateMainMenu(VOID)<br>{<br>HMENU hMenu = CreateMenu();<br>HMENU hFile = CreateMenu();<br>HMENU hEdit = CreateMenu();<br>HMENU hForm = CreateMenu();<br>HMENU hHelp = CreateMenu();<br><br>if(hMenu&amp;&amp;hFile){<br>AppendMenu(hFile,MF_STRING,MENU_ID_NEW ,TEXT("&amp;New Ctrl + N"));<br>AppendMenu(hFile,MF_STRING,MENU_ID_OPEN ,TEXT("&amp;Open... Ctrl + O"));<br>AppendMenu(hFile,MF_STRING,MENU_ID_SAVE ,TEXT("&amp;Save Ctrl + S"));<br>AppendMenu(hFile,MF_STRING,MENU_ID_SAVEAS ,TEXT("Save &amp;As..."));<br>AppendMenu(hFile,MF_SEPARATOR,0,TEXT(""));<br>AppendMenu(hFile,MF_STRING,MENU_ID_EXIT ,TEXT("E&amp;xit"));<br><br>AppendMenu(hEdit,MF_STRING,MENU_ID_UNDO ,TEXT("&amp;Undo Ctrl + Z"));<br>AppendMenu(hEdit,MF_SEPARATOR,0,TEXT(""));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_CUT ,TEXT("Cu&amp;t Ctrl + X"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_COPY ,TEXT("&amp;Copy Ctrl + C"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_PASTE ,TEXT("&amp;Paste Ctrl + V"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_DEL ,TEXT("De&amp;l Del"));<br>AppendMenu(hEdit,MF_SEPARATOR,0,TEXT(""));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_FIND ,TEXT("&amp;Find Ctrl + F"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_NEXT ,TEXT("Find &amp;Next F3"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_REPLACE,TEXT("&amp;Replace Ctrl + H"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_GOTO ,TEXT("&amp;Goto Ctrl + G"));<br>AppendMenu(hEdit,MF_SEPARATOR,0,TEXT(""));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_SELALL ,TEXT("Select &amp;All Ctrl + A"));<br>AppendMenu(hEdit,MF_STRING,MENU_ID_DATE ,TEXT("&amp;Date/Time F5"));<br><br>AppendMenu(hForm,MF_STRING,MENU_ID_WRET ,TEXT("&amp;Want Return"));<br><br>AppendMenu(hHelp,MF_STRING,MENU_ID_ABOUT ,TEXT("&amp;About"));<br><br>AppendMenu(hMenu,MF_POPUP,(UINT)hFile ,TEXT("&amp;File"));<br>AppendMenu(hMenu,MF_POPUP,(UINT)hEdit ,TEXT("&amp;Edit"));<br>AppendMenu(hMenu,MF_POPUP,(UINT)hForm ,TEXT("F&amp;ormat"));<br>AppendMenu(hMenu,MF_POPUP,(UINT)hHelp ,TEXT("&amp;Help"));<br>}<br><br>return hMenu;<br>}<br><br>HACCEL CreateAccelerator(VOID)<br>{<br>ACCEL accel[] =<br>{<br>{ FVIRTKEY , VK_F3 , MENU_ID_NEXT },<br>{ FVIRTKEY , VK_F5 , MENU_ID_DATE },<br><br>{ FCONTROL | FVIRTKEY, TEXT(''S''), MENU_ID_SAVE },<br>{ FCONTROL | FVIRTKEY, TEXT(''N''), MENU_ID_NEW },<br>{ FCONTROL | FVIRTKEY, TEXT(''O''), MENU_ID_OPEN },<br>{ FCONTROL | FVIRTKEY, TEXT(''C''), MENU_ID_COPY },<br>{ FCONTROL | FVIRTKEY, TEXT(''V''), MENU_ID_PASTE },<br>{ FCONTROL | FVIRTKEY, TEXT(''X''), MENU_ID_CUT },<br>{ FCONTROL | FVIRTKEY, TEXT(''Z''), MENU_ID_UNDO },<br>{ FCONTROL | FVIRTKEY, TEXT(''A''), MENU_ID_SELALL },<br>{ FCONTROL | FVIRTKEY, TEXT(''F''), MENU_ID_FIND },<br>{ FCONTROL | FVIRTKEY, TEXT(''H''), MENU_ID_REPLACE },<br>{ FCONTROL | FVIRTKEY, TEXT(''G''), MENU_ID_GOTO },<br>};<br>INT nCnt = sizeof(accel)/sizeof(accel[0]);<br><br>return CreateAcceleratorTable(accel, nCnt);<br><br>}<br><br>HWND CreateEdit(DWORD dwStyle)<br>{<br>HWND hWnd;<br>RECT rect;<br><br>GetClientRect(hWinMain,&amp;rect);<br>hWnd = CreateWindow(TEXT("Edit"),TEXT(""),/<br>dwStyle,/<br>0,0,rect.right-rect.left,rect.bottom-rect.top,/<br>hWinMain,(HMENU)CTRL_ID_EDIT_TEXT,hInstance,NULL);<br>Edit_CanUndo(hWnd);<br>SendMessage(hWnd,EM_SETLIMITTEXT,MAX_EDIT,0);<br>}<br><br>HWND CreateStatusBar(VOID)<br>{<br>hWinStatus = CreateWindowEx(0,<br>TEXT("msctls_statusbar32"),NULL,/<br>WS_CHILD | WS_VISIBLE | SBS_SIZEGRIP,/<br>0,0,0,0,/<br>hWinMain,(HMENU)CTRL_ID_STATUSBAR,hInstance,NULL);<br>}<br><br>HWND CreatInputDlg(TCHAR* pTitle,INT nFlag)<br>{<br>TCHAR *pClassName = TEXT("MyInputDlg");<br>const TCHAR *pStatic = szError;<br><br>WNDCLASSEX stWndClass;<br>MSG stMsg;<br>HWND hNewWnd;<br>RECT rect;<br><br>INT nDlgX = 200;<br>INT nDlgY = 200;<br>INT nDlgW = 160;<br>INT nDlgH = 120;<br><br>INT nCtrlH = 24;<br>INT nStaticX = 10;<br>INT nEditX = 50;<br>INT nLine1Y = 15;<br>INT nLine2Y = 50;<br>INT nStaticW = 35;<br>INT nEditW = 90;<br><br>INT nButtonW = 60;<br>INT nButtonY = 50;<br>INT nButton1X = 10;<br>INT nButton2X = nDlgW - nButtonW - nButton1X*2;<br><br>if(FLAG_INPUTDLG_TWOLINE == nFlag){<br>nDlgH += (10 + nCtrlH);<br>nButtonY += (10 + nCtrlH);<br>nStaticW += 35;<br>nEditX += 35;<br>nDlgW += 35;<br>nButton2X += 35;<br>}<br><br>RtlZeroMemory(&amp;stWndClass,sizeof(stWndClass));<br>stWndClass.hCursor = LoadCursor(0,IDC_ARROW);<br>stWndClass.hInstance = GetModuleHandle(NULL);<br>stWndClass.cbSize = sizeof(WNDCLASSEX);<br>stWndClass.style = CS_HREDRAW | CS_VREDRAW;<br>stWndClass.lpfnWndProc = (WNDPROC)_ProcInputDlg;<br>stWndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);<br>stWndClass.lpszClassName = pClassName;<br><br>RegisterClassEx(&amp;stWndClass);<br><br>hInputDlg = CreateWindowEx(WS_EX_CLIENTEDGE,<br>pClassName,pTitle,/<br>WS_OVERLAPPEDWINDOW,/<br>nDlgX,nDlgY,nDlgW,nDlgH,/<br>NULL,NULL,hInstance,NULL);<br><br>if(FLAG_INPUTFLG_GOTO == nInputDlgSts){<br>pStatic = szGoto;<br>}<br>else if(FLAG_INPUTFLG_FIND == nInputDlgSts){<br>pStatic = szFind;<br>}<br>else if(FLAG_INPUTFLG_REPLACE == nInputDlgSts){<br>pStatic = szFind;<br>}<br>else{<br>}<br>hNewWnd = CreateWindow(TEXT("Static"),pStatic,/<br>WS_CHILDWINDOW|WS_VISIBLE|WS_BORDER,/<br>nStaticX,nLine1Y,nStaticW,nCtrlH,/<br>hInputDlg,(HMENU)CTRL_ID_STATIC,hInstance,NULL);<br>ShowWindow(hNewWnd,SW_SHOWNORMAL);<br><br>hNewWnd = CreateWindow(TEXT("Edit"),TEXT(""),/<br>WS_CHILDWINDOW|WS_VISIBLE|WS_BORDER|WS_TABSTOP,/<br>nEditX,nLine1Y,nEditW,nCtrlH,/<br>hInputDlg,(HMENU)CTRL_ID_EDIT_INPUT,hInstance,NULL);<br>SetFocus(hNewWnd);<br>ShowWindow(hNewWnd,SW_SHOWNORMAL);<br><br>if(FLAG_INPUTDLG_TWOLINE == nFlag){<br>hNewWnd = CreateWindow(TEXT("Static"),szReplace,/<br>WS_CHILDWINDOW|WS_VISIBLE|WS_BORDER,/<br>nStaticX,nLine2Y,nStaticW,nCtrlH,/<br>hInputDlg,(HMENU)CTRL_ID_STATIC,hInstance,NULL);<br>ShowWindow(hNewWnd,SW_SHOWNORMAL);<br><br>hNewWnd = CreateWindow(TEXT("Edit"),TEXT(""),/<br>WS_CHILDWINDOW|WS_VISIBLE|WS_BORDER|WS_TABSTOP,/<br>nEditX,nLine2Y,nEditW,nCtrlH,/<br>hInputDlg,(HMENU)CTRL_ID_EDIT_REPLACE,hInstance,NULL);<br>ShowWindow(hNewWnd,SW_SHOWNORMAL);<br>}<br><br>hNewWnd = CreateWindow(TEXT("Button"),TEXT("&amp;OK"),/<br>WS_CHILDWINDOW|WS_VISIBLE|WS_GROUP|WS_TABSTOP,/<br>nButton1X,nButtonY,nButtonW,nCtrlH,/<br>hInputDlg,(HMENU)CTRL_ID_BTN_INPUT,hInstance,NULL);<br>ShowWindow(hNewWnd,SW_SHOWNORMAL);<br><br>hNewWnd = CreateWindow(TEXT("Button"),TEXT("&amp;Cancel"),/<br>WS_CHILDWINDOW|WS_VISIBLE|WS_GROUP|WS_TABSTOP,/<br>nButton2X,nButtonY,nButtonW,nCtrlH,/<br>hInputDlg,(HMENU)CTRL_ID_BTN_CANCEL,hInstance,NULL);<br>ShowWindow(hNewWnd,SW_SHOWNORMAL);<br><br>ShowWindow(hInputDlg,SW_SHOWNORMAL);<br>UpdateWindow(hInputDlg);<br><br>return hInputDlg;<br>}<br><br>BOOL _PreTranslateMessage(MSG* pMsg)<br>{<br>BOOL bRet = TRUE;<br>if((NULL != hInputDlg)&amp;&amp;(WM_KEYDOWN == pMsg-&gt;message)){<br>if((VK_RETURN == pMsg-&gt;wParam)||<br>(VK_ESCAPE == pMsg-&gt;wParam)<br>){<br>SendMessage(hInputDlg,pMsg-&gt;message,pMsg-&gt;wParam,pMsg-&gt;lParam);<br>}<br>else if(VK_TAB == pMsg-&gt;wParam){<br>OnInputDlgTab();<br>bRet = FALSE;<br>}<br>}<br><br>if((GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT) == pMsg-&gt;hwnd)&amp;&amp;<br>((WM_KEYUP == pMsg-&gt;message)||(WM_LBUTTONUP == pMsg-&gt;message))){<br>OnEditCurMoved();<br>}<br><br>if(WM_DROPFILES == pMsg-&gt;message){<br>SendMessage(hWinMain,pMsg-&gt;message,pMsg-&gt;wParam,pMsg-&gt;lParam);<br>}<br><br>return bRet;<br>}<br><br>INT _WinMain(VOID)<br>{<br>MSG stMsg;<br>HWND hNewWnd;<br>HMENU hMenu;<br>HACCEL hAccelerator;<br>WNDCLASSEX stWndClass;<br><br>hMenu = CreateMainMenu();<br>hAccelerator = CreateAccelerator();<br>hInstance = GetModuleHandle(NULL);<br><br>memset(&amp;stWndClass,0,sizeof(stWndClass));<br>stWndClass.hCursor = LoadCursor(0,IDC_ARROW);<br>stWndClass.hInstance = hInstance;<br>stWndClass.cbSize = sizeof(WNDCLASSEX);<br>stWndClass.style = CS_HREDRAW | CS_VREDRAW;<br>stWndClass.lpfnWndProc = (WNDPROC)_ProcWinMain;<br>stWndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);<br>stWndClass.lpszClassName = szClassName;<br><br>RegisterClassEx(&amp;stWndClass);<br><br>hWinMain = CreateWindowEx(WS_EX_CLIENTEDGE|WS_EX_ACCEPTFILES,/<br>szClassName,szCaptionMain,/<br>WS_OVERLAPPEDWINDOW,/<br>100,100,600,400,/<br>NULL,hMenu,hInstance,hAccelerator);<br>ModifyWinTitle();<br><br>hNewWnd = CreateEdit(WS_CHILDWINDOW|WS_VISIBLE|ES_MULTILINE|ES_WANTRETURN|/<br>ES_AUTOHSCROLL|ES_AUTOVSCROLL|WS_VSCROLL|WS_HSCROLL);<br>SetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));<br><br>CreateStatusBar();<br><br>OpenGivenFile(cCrtFile);<br><br>ShowWindow(hWinMain,SW_SHOWNORMAL);<br>UpdateWindow(hWinMain);<br><br>while(TRUE){<br><br>if(GetMessage(&amp;stMsg,NULL,0,0)==0){<br>break;<br>}<br><br>if(!(TranslateAccelerator(hWinMain,hAccelerator,&amp;stMsg))){<br>TranslateMessage(&amp;stMsg);<br>if(_PreTranslateMessage(&amp;stMsg)){<br>DispatchMessage(&amp;stMsg);<br>}<br>}<br><br>}<br><br>return 0;<br><br>}<br><br>/* There is no wmain in mingw 5.1.6 */<br>/* I find a "#if 0" in tchar.h , but don''t know why ... */<br>INT main(INT argc, TCHAR *argv[ ], CHAR *env[])<br>{<br>bUndo = FALSE;<br>bWantReturn = FALSE;<br><br>hInputDlg = NULL;<br>hInstance = NULL;<br>hWinMain = NULL;<br>hWinStatus = NULL;<br><br>nInputDlgSts = FLAG_INPUTFLG_NONE;<br><br>memset(cCrtFile,0,sizeof(cCrtFile));<br>memset(cInputEdit,0,sizeof(cInputEdit));<br><br>if(argc &gt; 1){<br>#ifdef UNICODE<br>/* The command line is in ansi format , need convert. */<br>INT nSize = _tcslen(argv[1])* sizeof(TCHAR);<br>MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,<br>(CHAR*)argv[1],nSize,<br>cCrtFile,nSize * sizeof(TCHAR));<br>#else<br>_tcscpy(cCrtFile,argv[1]);<br>#endif<br>}<br><br>_WinMain();<br>ExitProcess(0);<br><br>return 0;<br>}<br><br>VOID DEBUG_Output(TCHAR* lpszFormat, ...)<br>{<br>#ifdef DEBUG<br>TCHAR tcBuff[MAX_STRING];<br>va_list args;<br><br>va_start(args, lpszFormat);<br>_vstprintf(tcBuff,lpszFormat,args);<br>va_end(args);<br><br>MessageBox(NULL,tcBuff,TEXT("DEBUG"),MB_OK);<br>#endif<br>}</pre><br>原文发表于：<a href="http://blog.csdn.net/zeerd">2010-02-12 22:24</a><br>PS：这么长的代码几乎没有注释……汗啊！
