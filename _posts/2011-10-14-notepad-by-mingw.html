


---
layout: post
title: 旧文整理：MinGW写的简易记事本 Ver0.02
tags: [MinGW,Notepad,Windows]
---
<h2>{{ page.title }}</h2>
'MinGW下编写的记事本，也可以认为是API编程，SDK编程什么的。反正是没使用MFC……我不是科班出身的，这些名词界限搞不懂……\n使用-mwindows参数编译……\n<pre class="brush: cpp; gutter: true">#define _UNICODE /* for std c */\n#define UNICODE /* for windows api */\n\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;windowsx.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;commdlg.h&gt;\n#include &lt;commctrl.h&gt;\n\n/*============================================================================*/\n/*DEBUG(Add the define below if need) */\n#define DEBUG\nVOID DEBUG_Output(TCHAR* lpszFormat, ...);\n\n/*============================================================================*/\n/*CTRL ID */\n#define CTRL_ID_STATIC (0)\n#define CTRL_ID_EDIT_TEXT (1)\n#define CTRL_ID_EDIT_INPUT (2)\n#define CTRL_ID_EDIT_REPLACE (3)\n#define CTRL_ID_BTN_INPUT (4)\n#define CTRL_ID_BTN_CANCEL (5)\n#define CTRL_ID_STATUSBAR (6)\n\n/*============================================================================*/\n/*MENU ID */\n#define MENU_ID_NEW (10)\n#define MENU_ID_OPEN (11)\n#define MENU_ID_SAVE (12)\n#define MENU_ID_SAVEAS (13)\n#define MENU_ID_EXIT (14)\n\n#define MENU_ID_UNDO (20)\n#define MENU_ID_COPY (21)\n#define MENU_ID_PASTE (22)\n#define MENU_ID_CUT (23)\n#define MENU_ID_DEL (24)\n#define MENU_ID_SELALL (25)\n#define MENU_ID_GOTO (26)\n#define MENU_ID_FIND (27)\n#define MENU_ID_NEXT (28)\n#define MENU_ID_REPLACE (29)\n#define MENU_ID_DATE (30)\n\n#define MENU_ID_WRET (40)\n\n#define MENU_ID_ABOUT (50)\n\n/*============================================================================*/\n/* CONST DEFINE */\n#define MAX_STRING (256)\n\n/* The return value of the most APIs is limited in integer. */\n/* So limit the max edit characters'' number to 65535 */\n/* If need to deal with any files larger than 65535 bytes , */\n/* Some complex arithmetics (i.e. column number) should to be added. */\n#define MAX_EDIT (65535U)\n\n/* One line''s one used for Goto and Find , two used for Repalce */\n#define FLAG_INPUTDLG_ONELINE (0)\n#define FLAG_INPUTDLG_TWOLINE (1)\n\n#define FLAG_INPUTFLG_NONE (0)\n#define FLAG_INPUTFLG_GOTO (1)\n#define FLAG_INPUTFLG_FIND (2)\n#define FLAG_INPUTFLG_REPLACE (3)\n\n#ifdef UNICODE\n#define SN_CF_TEXT (CF_UNICODETEXT)\n#else\n#define SN_CF_TEXT (CF_TEXT)\n#endif\n\n/*============================================================================*/\n/* TYPEDEF */\ntypedef struct{\nUINT nID;\nTCHAR *pText;\n}MenuString_st;\n\n/*============================================================================*/\n/* CONST VARIABLE */\nconst TCHAR *szClassName = TEXT("MySimpleNotepad");\nconst TCHAR *szCaptionMain = TEXT("Simple Notepad Ver0.02");\nconst TCHAR *szFind = TEXT("Find:");\nconst TCHAR *szReplace = TEXT("Replace:");\nconst TCHAR *szGoto = TEXT("Goto:");\nconst TCHAR *szError = TEXT("Error");\nconst TCHAR *szSaveModify = TEXT("Save the modify?");\n\nconst MenuString_st stMenuString[]={\n{MENU_ID_NEW ,TEXT("New a file.")},\n{MENU_ID_OPEN ,TEXT("Open a file.")},\n{MENU_ID_SAVE ,TEXT("Save the file.")},\n{MENU_ID_SAVEAS ,TEXT("Save the texts to an other file.")}\n};\n\n/*============================================================================*/\n/* VARIABLE */\nHANDLE hInstance;\nHWND hWinMain;\nHWND hInputDlg;\nHWND hWinStatus;\n\nINT nInputDlgSts;\n\nBOOL bUndo;\nBOOL bWantReturn;\n\nTCHAR cCrtFile[MAX_PATH];\nTCHAR cInputEdit[MAX_STRING];\n\n/*============================================================================*/\n/* PROTOTYPE */\nINT _WinMain(VOID);\n\nLRESULT CALLBACK _ProcWinMain(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam);\nLRESULT CALLBACK _ProcInputDlg(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam);\nBOOL _PreTranslateMessage(MSG* pMsg);\n\nHWND CreateEdit(DWORD dwStyle);\nHWND CreatInputDlg(TCHAR* pTitle,INT nFlag);\nHWND CreateStatusBar(VOID);\nHMENU CreateMainMenu(VOID);\nHACCEL CreateAccelerator(VOID);\n\nVOID OnSetFocus(VOID);\nVOID OnSize(VOID);\nVOID OnAbout(VOID);\nVOID OnQuit(VOID);\nVOID OnNew(VOID);\nVOID OnOpen(VOID);\nVOID OnSave(INT nFlag);\nVOID OnUndo(VOID);\nVOID OnCopy(VOID);\nVOID OnPaste(VOID);\nVOID OnCut(VOID);\nVOID OnDel(VOID);\nVOID OnSelAll(VOID);\nVOID OnWantReturn(VOID);\nVOID OnGoto(INT nFlag);\nVOID OnFind(INT nFlag);\nVOID OnReplace(INT nFlag);\nVOID OnDateTime(VOID);\nVOID OnMenuSelect(UINT);\n\nVOID OnEditCurMoved(VOID);\n\nVOID OnInputDlgClose(HWND hWnd);\nVOID OnInputDlgTab(VOID);\n\nVOID ModifyWinTitle(VOID);\nVOID OpenGivenFile(TCHAR *pFile);\nBOOL Find(TCHAR tcFind[],DWORD *dwStart,DWORD *dwEnd);\nBOOL Edit_GetSelText(HWND hWnd,TCHAR *pBuffer,INT nLenMax);\n\n/*============================================================================*/\n/* FUNCTION */\nVOID ModifyWinTitle(VOID)\n{\nTCHAR *cTitle;\nINT nSize = MAX_PATH + _tcslen(szCaptionMain)\n+ 3 /* For the length of " - " */\n+ 1; /* For the length of "*" */\ncTitle = malloc(nSize * sizeof(TCHAR));\nZeroMemory(cTitle,nSize);\n_stprintf(cTitle,TEXT("%s%s - %s"),\n(_tcslen(cCrtFile)==0)?TEXT("Untitled"):cCrtFile,\n(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))?TEXT("*"):TEXT("")),\nszCaptionMain);\nSetWindowText(hWinMain,cTitle);\nfree(cTitle);\n}\n\nVOID OnSetFocus(VOID)\n{\nif(GetFocus() != GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT)){\nSetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n}\n}\n\nVOID OnSize(VOID)\n{\nRECT stRect;\nRECT stRectSts;\n\n/* Keep the status at the bottom of the dlg */\nMoveWindow(hWinStatus,0,0,0,0,TRUE);\n\n/* Adjust the size of the edit ctrl */\nGetClientRect(hWinMain,&amp;stRect);\nGetWindowRect(hWinStatus,&amp;stRectSts);\n\nMoveWindow(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),/\n0,0,\nstRect.right-stRect.left,\nstRect.bottom-stRect.top-stRectSts.bottom+stRectSts.top,\nFALSE);\n\n/* Adjust the width of each part in the status dynamically */\nDWORD dwStatusWidth[] = {0,-1};\ndwStatusWidth[0] = stRect.right/3*2;\nSendMessage(hWinStatus,SB_SETPARTS,2,(LPARAM)dwStatusWidth);\n}\n\nVOID OnAbout(VOID)\n{\nMessageBox(NULL,TEXT("Copyleft (C) 2010/n/nCompiler:MinGW-5.1.6[gcc version 3.4.5 (mingw-vista special r3) (with option -mwindows)]/n/nComment:The max file size is 65535 Bytes."),TEXT("About..."),MB_OK);\n}\n\nVOID OnQuit(VOID)\n{\nif(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))){\nINT nID = MessageBox(NULL,szSaveModify,szCaptionMain,MB_OKCANCEL);\nif(IDOK == nID){\nOnSave(0);\n}\n}\nelse{\n}\nDestroyWindow(hWinMain);\nPostQuitMessage(0);\n}\n\nVOID OnNew(VOID)\n{\nif(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))){\nINT nID = MessageBox(NULL,szSaveModify,szCaptionMain,MB_OKCANCEL);\nif(IDOK == nID){\nOnSave(0);\n}\n}\nelse{\n}\nSetWindowText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),TEXT(""));\n}\n\nVOID OpenGivenFile(TCHAR *pFile)\n{\nHANDLE hFile;\nDWORD dwSize,Num;\nCHAR *lpMultiByteStr;\nTCHAR *lpWideCharStr;\n\nhFile=CreateFile(pFile,GENERIC_READ,0,NULL,OPEN_ALWAYS,\nFILE_ATTRIBUTE_NORMAL,NULL);\nif(INVALID_HANDLE_VALUE!= hFile )\n{\nSetFilePointer(hFile,0,0,FILE_BEGIN);\n\ndwSize = GetFileSize(hFile,NULL);\n\nlpMultiByteStr = malloc((dwSize+1) * sizeof(CHAR)); /*NOT sure if need to reserve a byte for ''/0'' */\nZeroMemory(lpMultiByteStr,(dwSize+1) * sizeof(CHAR));\n\n#ifdef UNICODE\n/* The text file is based on ansi , but the edit ctrl is based on unicode. */\n/* So need to convert the ansi strings to unicode format. */\nlpWideCharStr = malloc((dwSize+1) * sizeof(TCHAR)); /*NOT sure if need to reserve a byte for ''/0'' */\nZeroMemory(lpWideCharStr,(dwSize+1) * sizeof(TCHAR));\n\nReadFile(hFile,lpMultiByteStr,dwSize,&amp;Num,NULL);\n\nMultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,\nlpMultiByteStr,(dwSize) * sizeof(CHAR),\nlpWideCharStr,(dwSize) * sizeof(TCHAR));\n#else\nlpWideCharStr = lpMultiByteStr;\n#endif\n\nEdit_SetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),lpWideCharStr);\n\nfree(lpMultiByteStr);\n#ifdef UNICODE\nfree(lpWideCharStr);\n#endif\nCloseHandle(hFile);\n}\n\nModifyWinTitle();\n\nSetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n}\n\nVOID OnOpen(VOID)\n{\nif(Edit_GetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))){\nINT nID = MessageBox(NULL,szSaveModify,szCaptionMain,MB_OKCANCEL);\nif(IDOK == nID){\nOnSave(0);\n}\n}\nelse{\n}\n\nTCHAR *cFilter = TEXT("Non-Unicode Text File(*.txt)/0*.TXT/0");\nOPENFILENAME ofFile;\n\nmemset(&amp;ofFile,0,sizeof(OPENFILENAME));\nofFile.lStructSize = sizeof(OPENFILENAME);\nofFile.hwndOwner = hWinMain;\nofFile.hInstance = hInstance;\nofFile.lpstrFilter = cFilter;\nofFile.lpstrTitle = TEXT("Open");\nofFile.lpstrFile = cCrtFile;\nofFile.nMaxFile = MAX_PATH;\nofFile.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;\n\nif(GetOpenFileName(&amp;ofFile)){\nOpenGivenFile(cCrtFile);\n}\n\n}\n\nVOID OnSave(INT nFlag)\n{\nif((nFlag) || (_tcslen(cCrtFile)==0)){\nTCHAR *cFilter = TEXT("Non-Unicode Text File(*.txt)/0*.TXT/0");\nOPENFILENAME ofFile;\n\nmemset(&amp;ofFile,0,sizeof(OPENFILENAME));\nofFile.lStructSize = sizeof(OPENFILENAME);\nofFile.hwndOwner = hWinMain;\nofFile.hInstance = hInstance;\nofFile.lpstrFilter = cFilter;\nofFile.lpstrTitle = TEXT("Save As");\nofFile.lpstrFile = cCrtFile;\nofFile.nMaxFile = MAX_PATH;\nofFile.lpstrDefExt = TEXT(".txt");\nofFile.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;\n\nGetSaveFileName(&amp;ofFile);\n}\nelse{\n}\n\nif(_tcslen(cCrtFile) != 0){\nHANDLE hFile;\nDWORD dwSize,Num;\nCHAR *lpMultiByteStr;\nTCHAR *lpWideCharStr;\nhFile=CreateFile(cCrtFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,\nFILE_ATTRIBUTE_NORMAL,NULL);\nif(INVALID_HANDLE_VALUE!= hFile )\n{\n\nSetFilePointer(hFile,0,0,FILE_BEGIN);\n\ndwSize = Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))+1;\n\nlpWideCharStr = malloc((dwSize) * sizeof(TCHAR));\nZeroMemory(lpWideCharStr,(dwSize) * sizeof(TCHAR));\n\n#ifdef UNICODE\n/* The text file is based on ansi , but the edit ctrl is based on unicode. */\n/* So need to convert the unicode strings to ansi format. */\nlpMultiByteStr = malloc((dwSize) * sizeof(CHAR));\nZeroMemory(lpMultiByteStr,(dwSize) * sizeof(CHAR));\n\nEdit_GetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),lpWideCharStr,dwSize);\n\nWideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK,\nlpWideCharStr,dwSize * sizeof(TCHAR),\nlpMultiByteStr,dwSize * sizeof(CHAR),\nNULL,NULL);\n#else\nlpMultiByteStr = lpWideCharStr;\n#endif\n\nWriteFile(hFile,lpMultiByteStr,dwSize,&amp;Num,NULL);\n\n#ifdef UNICODE\nfree(lpMultiByteStr);\n#endif\nfree(lpWideCharStr);\n\nCloseHandle(hFile);\n\nEdit_SetModify(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),FALSE);\n}\n}\n\nModifyWinTitle();\n}\n\nVOID OnUndo(VOID)\n{\nEdit_Undo(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n}\n\nVOID OnCopy(VOID)\n{\nTCHAR * pText;\nHANDLE hGlobal;\nPTSTR pGlobal ;\nDWORD dwGetSel;\nDWORD dwEditLen;\n\ndwGetSel = Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\ndwEditLen = Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n\npText = malloc((dwEditLen+1) * sizeof(TCHAR));\nEdit_GetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),pText,dwEditLen);\n\nhGlobal = GlobalAlloc (GHND | GMEM_SHARE, (HIWORD(dwGetSel) - LOWORD(dwGetSel) + 1) * sizeof (TCHAR)) ;\npGlobal = GlobalLock (hGlobal) ;\n_tcsncpy (pGlobal, &amp;pText[LOWORD(dwGetSel)],HIWORD(dwGetSel) - LOWORD(dwGetSel)) ;\nGlobalUnlock (hGlobal) ;\nOpenClipboard (hWinMain) ;\nEmptyClipboard () ;\nSetClipboardData (SN_CF_TEXT, hGlobal) ;\nCloseClipboard () ;\n}\n\nVOID OnPaste(VOID)\n{\nHANDLE hGlobal;\nPTSTR pGlobal ;\nOpenClipboard (hWinMain) ;\nif (IsClipboardFormatAvailable (SN_CF_TEXT)) {\nhGlobal = GetClipboardData (SN_CF_TEXT);\npGlobal = GlobalLock (hGlobal) ;\nEdit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),pGlobal);\nGlobalUnlock (hGlobal) ;\n}\nCloseClipboard () ;\n\n}\n\nVOID OnCut(VOID)\n{\nOnCopy();\nOnDel();\n}\n\nVOID OnDel(VOID)\n{\nEdit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),TEXT(""));\n}\n\nVOID OnSelAll(VOID)\n{\nEdit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),\n0,\nEdit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT)));\n}\n\nVOID OnWantReturn(VOID)\n{\nDWORD dwStyle;\n\nbWantReturn = !bWantReturn;\n\ndwStyle = GetWindowLong(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),GWL_STYLE);\nif(bWantReturn){\ndwStyle &amp;= (~(ES_AUTOHSCROLL|WS_HSCROLL)) ;\n}\nelse{\ndwStyle |= (ES_AUTOHSCROLL)|(WS_HSCROLL) ;\n}\n\n/* Cound not change the style after an edit-ctrl-created. */\n/* So need to re-create the edit ctrl for style changing. */\nDestroyWindow(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\nCreateEdit(dwStyle);\nif(_tcslen(cCrtFile) != 0){\nOpenGivenFile(cCrtFile);\n}\n}\n\nVOID OnDateTime(VOID)\n{\ntime_t t;\nstruct tm *newtime;\nTCHAR tcDate[MAX_STRING];\n\ntime(&amp;t);\nnewtime = localtime( &amp;t );\n_stprintf(tcDate,TEXT("%02d:%02d %04d-%02d-%02d"),/\nnewtime-&gt;tm_hour,newtime-&gt;tm_min,/\nnewtime-&gt;tm_year+1900,newtime-&gt;tm_mon+1, newtime-&gt;tm_mday\n);\nEdit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),tcDate);\n}\n\nVOID OnEditCurMoved(VOID)\n{\nINT nRow,nCol;\nTCHAR tcBuff[MAX_STRING];\n\n/* Use EM_LINEFROMCHAR to get the current line. */\nnRow = Edit_LineFromChar(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),-1);\n/* We could get the index of the current charactor in an edit ctrl (A)\nand the count of the charactors till the last line (B)\nSo the value of A-B would be the column.*/\nnCol = HIWORD(Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))) - /\nEdit_LineIndex(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),-1);\n_stprintf(tcBuff,TEXT("Ln %d, Col %d"),nRow+1,nCol+1);\n\n/* Used to update the Line and column info in status bar. */\nSendMessage(hWinStatus,SB_SETTEXT,1,(LPARAM)tcBuff);\n\n}\n\nVOID OnMenuSelect(UINT uItem)\n{\nINT n,nIdCnt = sizeof(stMenuString)/sizeof(stMenuString[0]);\n\n/* Used to update the menu hint info in status bar. */\nfor(n=0;n&lt;nIdCnt;n++){\nif(uItem == stMenuString[n].nID){\nSendMessage(hWinStatus,SB_SETTEXT,0,(LPARAM)stMenuString[n].pText);\nbreak;\n}\n}\n\nif(n &gt;= nIdCnt){\nSendMessage(hWinStatus,SB_SETTEXT,0,(LPARAM)TEXT(""));\n}\n}\n\nLRESULT CALLBACK _ProcWinMain(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam)\n{\nif(WM_SIZE == uMsg){\nOnSize();\n}\nelse if(WM_CLOSE == uMsg){\nOnQuit();\n}\nelse if(WM_SETFOCUS == uMsg){\nOnSetFocus();\n}\nelse if(WM_INITMENUPOPUP == uMsg){\n//if((UINT) LOWORD(lParam) == 1){\nBOOL bEnable;\nbEnable = (Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT)) != 0) ? MF_ENABLED : MF_GRAYED ;\nEnableMenuItem ((HMENU) wParam, MENU_ID_UNDO, bUndo ? MF_ENABLED : MF_GRAYED) ;\nEnableMenuItem ((HMENU) wParam, MENU_ID_PASTE, IsClipboardFormatAvailable (SN_CF_TEXT) ? MF_ENABLED : MF_GRAYED) ;\nEnableMenuItem ((HMENU) wParam, MENU_ID_CUT, bEnable) ;\nEnableMenuItem ((HMENU) wParam, MENU_ID_COPY, bEnable) ;\nEnableMenuItem ((HMENU) wParam, MENU_ID_DEL, bEnable) ;\n//}\n\nCheckMenuItem((HMENU) wParam,MENU_ID_WRET , bWantReturn?MF_CHECKED:MF_UNCHECKED);\n}\nelse if(WM_MENUSELECT == uMsg){\nOnMenuSelect((UINT) LOWORD(wParam));\n}\nelse if(WM_DROPFILES == uMsg){\nTCHAR lpszFileName[MAX_PATH];\nDragQueryFile((HANDLE)wParam, 0, lpszFileName, MAX_PATH);\nOpenGivenFile(lpszFileName);\n_tcscpy(cCrtFile,lpszFileName);\n}\nelse if((WM_COMMAND == uMsg)/*&amp;&amp;(HIWORD(wParam) == BN_CLICKED)*/){\nWORD wNotifyCode = HIWORD(wParam); // notification code\nWORD wID = LOWORD(wParam); // item, control, or accelerator identifier\nHWND hCtl = (HWND) lParam; // handle of control\n/*if(HIWORD(wParam) == BN_CLICKED){*/\nswitch(wID){\ncase MENU_ID_ABOUT:\nOnAbout();\nbreak;\ncase MENU_ID_EXIT:\nOnQuit();\nbreak;\ncase MENU_ID_NEW:\nOnNew();\nbreak;\ncase MENU_ID_OPEN:\nOnOpen();\nbreak;\ncase MENU_ID_SAVE:\nOnSave(0);\nbreak;\ncase MENU_ID_SAVEAS:\nOnSave(1);\nbreak;\ncase MENU_ID_UNDO:\nOnUndo();\nbreak;\ncase MENU_ID_COPY:\nOnCopy();\nbreak;\ncase MENU_ID_PASTE:\nOnPaste();\nbreak;\ncase MENU_ID_CUT:\nOnCut();\nbreak;\ncase MENU_ID_DEL:\nOnDel();\nbreak;\ncase MENU_ID_SELALL:\nOnSelAll();\nbreak;\ncase MENU_ID_WRET:\nOnWantReturn();\nbreak;\ncase MENU_ID_GOTO:\nOnGoto(0);\nbreak;\ncase MENU_ID_FIND:\nOnFind(0);\nbreak;\ncase MENU_ID_NEXT:\nOnFind(1);\nbreak;\ncase MENU_ID_REPLACE:\nOnReplace(0);\nbreak;\ncase MENU_ID_DATE:\nOnDateTime();\nbreak;\ndefault:\nDefWindowProc(hWnd,uMsg,wParam,lParam);\nbreak;\n}\n/*}\nelse */if(EN_CHANGE == HIWORD(wParam)){\nModifyWinTitle();\nbUndo = TRUE;\n}\nelse{\nDefWindowProc(hWnd,uMsg,wParam,lParam);\n}\n\n}\nelse{\nDefWindowProc(hWnd,uMsg,wParam,lParam);\n}\n\n}\n\nVOID OnGoto(INT nFlag)\n{\nINT nLine;\nTCHAR cBuff[MAX_STRING];\n\nif(0 == nFlag){\nnInputDlgSts = FLAG_INPUTFLG_GOTO;\nCreatInputDlg(TEXT("Goto:"),FLAG_INPUTDLG_ONELINE);\n/* Set the current line number to default */\nnLine = Edit_LineFromChar(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),-1) + 1;\n_itot(nLine,cBuff,10);\nEdit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cBuff);\n}\nelse{\nEdit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cInputEdit,MAX_STRING);\nnLine = Edit_LineIndex(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),_ttoi(cInputEdit)-1);\nEdit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),nLine,nLine);\nSetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n}\n}\n\nBOOL Find(TCHAR tcFind[],DWORD *dwStart,DWORD *dwEnd)\n{\nDWORD dwSize,Num;\nDWORD dwFindStart;\nTCHAR *cBuffer;\nBOOL bRet = FALSE;\n\ndwSize = Edit_GetTextLength(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT))+1;\ncBuffer = malloc(dwSize * sizeof(TCHAR));\nZeroMemory(cBuffer,dwSize * sizeof(TCHAR));\n\nEdit_GetText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cBuffer,dwSize);\n\ndwFindStart = Edit_GetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\ndwFindStart = HIWORD(dwFindStart);\n\nif(dwFindStart &lt; dwSize){\nTCHAR *pFound = _tcsstr(cBuffer+dwFindStart,tcFind);\nif(pFound != NULL){\n*dwStart = (DWORD)pFound - (DWORD)cBuffer;\n*dwEnd = *dwStart + _tcslen(tcFind);\nbRet = TRUE;\n}\n}\nfree(cBuffer);\n\nreturn bRet;\n}\n\nBOOL Edit_GetSelText(HWND hWnd,TCHAR *pBuffer,INT nLenMax)\n{\nBOOL bRet = TRUE;\n\nif(Edit_GetSel(hWnd) != 0){\nTCHAR * pText;\nDWORD dwGetSel;\nDWORD dwEditLen;\nDWORD dwSelLen;\n\ndwGetSel = Edit_GetSel(hWnd);\ndwEditLen = Edit_GetTextLength(hWnd);\n\npText = malloc((dwEditLen+1) * sizeof(TCHAR));\nEdit_GetText(hWnd,pText,dwEditLen);\n\ndwSelLen = HIWORD(dwGetSel) - LOWORD(dwGetSel);\ndwSelLen = (nLenMax &gt; dwSelLen)?dwSelLen:nLenMax;\n\n_tcsncpy (pBuffer, &amp;pText[LOWORD(dwGetSel)],dwSelLen) ;\n}\nelse{\nbRet = FALSE;\n}\n}\n\nVOID OnFind(INT nFlag)\n{\nstatic TCHAR cString[MAX_STRING] = TEXT("");\n\nDWORD dwStart,dwEnd;\n\nif(0 == nFlag){\nnInputDlgSts = FLAG_INPUTFLG_FIND;\nCreatInputDlg(_T("Find:"),FLAG_INPUTDLG_ONELINE);\n/* Set the selected text to default */\nEdit_GetSelText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cString,MAX_STRING);\nEdit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cString);\n}\nelse{\nif(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT)!=NULL){\nEdit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cString,MAX_STRING);\n}\n\nBOOL bFind = Find(cString,&amp;dwStart,&amp;dwEnd);\n\nif(bFind){\nEdit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),dwStart,dwEnd);\n}\nelse{\nTCHAR tcCaution[MAX_STRING] = TEXT("Can not find /"");\n_tcscat(tcCaution,cString);\n_tcscat(tcCaution,TEXT("/"!"));\nMessageBox(NULL,tcCaution,szCaptionMain,MB_OK);\n}\n\n}\n}\n\nVOID OnReplace(INT nFlag)\n{\nstatic TCHAR cFind[MAX_STRING] = TEXT("");\nstatic TCHAR cReplace[MAX_STRING] = TEXT("");\n\nDWORD dwStart,dwEnd;\n\nif(0 == nFlag){\nnInputDlgSts = FLAG_INPUTFLG_REPLACE;\nCreatInputDlg(_T("Replace:"),FLAG_INPUTDLG_TWOLINE);\n/* Set the selected text to default */\nEdit_GetSelText(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cFind,MAX_STRING);\nEdit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cFind);\nEdit_SetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_REPLACE),cReplace);\n}\nelse{\nEdit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_INPUT),cFind,MAX_STRING);\nEdit_GetText(GetDlgItem(hInputDlg,CTRL_ID_EDIT_REPLACE),cReplace,MAX_STRING);\n\nBOOL bFind = Find(cFind,&amp;dwStart,&amp;dwEnd);\n\nif(bFind){\nEdit_SetSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),dwStart,dwEnd);\nEdit_ReplaceSel(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT),cReplace);\n}\nelse{\nTCHAR tcCaution[MAX_STRING] = TEXT("Can not find /"");\n_tcscat(tcCaution,cFind);\n_tcscat(tcCaution,TEXT("/"!"));\nMessageBox(NULL,tcCaution,szCaptionMain,MB_OK);\n}\n\n}\n}\n\nVOID OnInputDlgClose(HWND hWnd)\n{\nnInputDlgSts = FLAG_INPUTFLG_NONE;\nDestroyWindow(hWnd);\nhInputDlg = NULL;\nSetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n}\n\nVOID OnInputDlgTab(VOID)\n{\n/* Tab order */\nINT nIdTab[][2]={\n{CTRL_ID_EDIT_INPUT ,CTRL_ID_EDIT_REPLACE },\n{CTRL_ID_EDIT_REPLACE ,CTRL_ID_BTN_INPUT },\n{CTRL_ID_BTN_INPUT ,CTRL_ID_BTN_CANCEL },\n{CTRL_ID_BTN_CANCEL ,CTRL_ID_EDIT_INPUT }\n};\nINT n,nIdCnt = sizeof(nIdTab)/sizeof(nIdTab[0]);\n\nINT nID = GetWindowLong(GetFocus(),GWL_ID);\n\nfor(n=0;n&lt;nIdCnt;n++){\nif(nID == nIdTab[n][0]){\nif(GetDlgItem(hInputDlg,nIdTab[n][1])!= NULL){\nSetFocus(GetDlgItem(hInputDlg,nIdTab[n][1]));\nbreak;\n}\nelse{\nnID = nIdTab[n][1];\n}\n}\n}\n}\n\nLRESULT CALLBACK _ProcInputDlg(HWND hWnd,DWORD uMsg,WPARAM wParam,LPARAM lParam)\n{\nif(WM_PAINT == uMsg){\nUpdateWindow(hWnd);\n}\nelse if(WM_CLOSE == uMsg){\nOnInputDlgClose(hWnd);\n}\nelse if(WM_KEYDOWN == uMsg){\nINT nVirtKey =(INT) wParam;\n\nif(nVirtKey == VK_ESCAPE){\nSendMessage(hWnd,WM_COMMAND,MAKELONG(CTRL_ID_BTN_CANCEL,BN_CLICKED),CTRL_ID_BTN_INPUT);\n}\nelse if(nVirtKey == VK_RETURN){\nSendMessage(hWnd,WM_COMMAND,MAKELONG(CTRL_ID_BTN_INPUT,BN_CLICKED),CTRL_ID_BTN_INPUT);\n}\n}\nelse if((WM_COMMAND == uMsg)/*&amp;&amp;(HIWORD(wParam) == BN_CLICKED)*/){\nWORD wNotifyCode = HIWORD(wParam); // notification code\nWORD wID = LOWORD(wParam); // item, control, or accelerator identifier\nHWND hCtl = (HWND) lParam; // handle of control\nswitch(wID){\ncase CTRL_ID_BTN_INPUT:\nif(FLAG_INPUTFLG_GOTO == nInputDlgSts){\nOnGoto(1);\nOnInputDlgClose(hWnd);\n}\nelse if(FLAG_INPUTFLG_FIND == nInputDlgSts){\nOnFind(1);\n}\nelse if(FLAG_INPUTFLG_REPLACE == nInputDlgSts){\nOnReplace(1);\n}\nelse{\n}\nbreak;\ncase CTRL_ID_BTN_CANCEL:\nOnInputDlgClose(hWnd);\nbreak;\ndefault:\nDefWindowProc(hWnd,uMsg,wParam,lParam);\nbreak;\n}\n}\nelse{\n//DefWindowProc(hWnd,uMsg,wParam,lParam);\n}\n\nDefWindowProc(hWnd,uMsg,wParam,lParam);\n}\n\nHMENU CreateMainMenu(VOID)\n{\nHMENU hMenu = CreateMenu();\nHMENU hFile = CreateMenu();\nHMENU hEdit = CreateMenu();\nHMENU hForm = CreateMenu();\nHMENU hHelp = CreateMenu();\n\nif(hMenu&amp;&amp;hFile){\nAppendMenu(hFile,MF_STRING,MENU_ID_NEW ,TEXT("&amp;New Ctrl + N"));\nAppendMenu(hFile,MF_STRING,MENU_ID_OPEN ,TEXT("&amp;Open... Ctrl + O"));\nAppendMenu(hFile,MF_STRING,MENU_ID_SAVE ,TEXT("&amp;Save Ctrl + S"));\nAppendMenu(hFile,MF_STRING,MENU_ID_SAVEAS ,TEXT("Save &amp;As..."));\nAppendMenu(hFile,MF_SEPARATOR,0,TEXT(""));\nAppendMenu(hFile,MF_STRING,MENU_ID_EXIT ,TEXT("E&amp;xit"));\n\nAppendMenu(hEdit,MF_STRING,MENU_ID_UNDO ,TEXT("&amp;Undo Ctrl + Z"));\nAppendMenu(hEdit,MF_SEPARATOR,0,TEXT(""));\nAppendMenu(hEdit,MF_STRING,MENU_ID_CUT ,TEXT("Cu&amp;t Ctrl + X"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_COPY ,TEXT("&amp;Copy Ctrl + C"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_PASTE ,TEXT("&amp;Paste Ctrl + V"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_DEL ,TEXT("De&amp;l Del"));\nAppendMenu(hEdit,MF_SEPARATOR,0,TEXT(""));\nAppendMenu(hEdit,MF_STRING,MENU_ID_FIND ,TEXT("&amp;Find Ctrl + F"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_NEXT ,TEXT("Find &amp;Next F3"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_REPLACE,TEXT("&amp;Replace Ctrl + H"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_GOTO ,TEXT("&amp;Goto Ctrl + G"));\nAppendMenu(hEdit,MF_SEPARATOR,0,TEXT(""));\nAppendMenu(hEdit,MF_STRING,MENU_ID_SELALL ,TEXT("Select &amp;All Ctrl + A"));\nAppendMenu(hEdit,MF_STRING,MENU_ID_DATE ,TEXT("&amp;Date/Time F5"));\n\nAppendMenu(hForm,MF_STRING,MENU_ID_WRET ,TEXT("&amp;Want Return"));\n\nAppendMenu(hHelp,MF_STRING,MENU_ID_ABOUT ,TEXT("&amp;About"));\n\nAppendMenu(hMenu,MF_POPUP,(UINT)hFile ,TEXT("&amp;File"));\nAppendMenu(hMenu,MF_POPUP,(UINT)hEdit ,TEXT("&amp;Edit"));\nAppendMenu(hMenu,MF_POPUP,(UINT)hForm ,TEXT("F&amp;ormat"));\nAppendMenu(hMenu,MF_POPUP,(UINT)hHelp ,TEXT("&amp;Help"));\n}\n\nreturn hMenu;\n}\n\nHACCEL CreateAccelerator(VOID)\n{\nACCEL accel[] =\n{\n{ FVIRTKEY , VK_F3 , MENU_ID_NEXT },\n{ FVIRTKEY , VK_F5 , MENU_ID_DATE },\n\n{ FCONTROL | FVIRTKEY, TEXT(''S''), MENU_ID_SAVE },\n{ FCONTROL | FVIRTKEY, TEXT(''N''), MENU_ID_NEW },\n{ FCONTROL | FVIRTKEY, TEXT(''O''), MENU_ID_OPEN },\n{ FCONTROL | FVIRTKEY, TEXT(''C''), MENU_ID_COPY },\n{ FCONTROL | FVIRTKEY, TEXT(''V''), MENU_ID_PASTE },\n{ FCONTROL | FVIRTKEY, TEXT(''X''), MENU_ID_CUT },\n{ FCONTROL | FVIRTKEY, TEXT(''Z''), MENU_ID_UNDO },\n{ FCONTROL | FVIRTKEY, TEXT(''A''), MENU_ID_SELALL },\n{ FCONTROL | FVIRTKEY, TEXT(''F''), MENU_ID_FIND },\n{ FCONTROL | FVIRTKEY, TEXT(''H''), MENU_ID_REPLACE },\n{ FCONTROL | FVIRTKEY, TEXT(''G''), MENU_ID_GOTO },\n};\nINT nCnt = sizeof(accel)/sizeof(accel[0]);\n\nreturn CreateAcceleratorTable(accel, nCnt);\n\n}\n\nHWND CreateEdit(DWORD dwStyle)\n{\nHWND hWnd;\nRECT rect;\n\nGetClientRect(hWinMain,&amp;rect);\nhWnd = CreateWindow(TEXT("Edit"),TEXT(""),/\ndwStyle,/\n0,0,rect.right-rect.left,rect.bottom-rect.top,/\nhWinMain,(HMENU)CTRL_ID_EDIT_TEXT,hInstance,NULL);\nEdit_CanUndo(hWnd);\nSendMessage(hWnd,EM_SETLIMITTEXT,MAX_EDIT,0);\n}\n\nHWND CreateStatusBar(VOID)\n{\nhWinStatus = CreateWindowEx(0,\nTEXT("msctls_statusbar32"),NULL,/\nWS_CHILD | WS_VISIBLE | SBS_SIZEGRIP,/\n0,0,0,0,/\nhWinMain,(HMENU)CTRL_ID_STATUSBAR,hInstance,NULL);\n}\n\nHWND CreatInputDlg(TCHAR* pTitle,INT nFlag)\n{\nTCHAR *pClassName = TEXT("MyInputDlg");\nconst TCHAR *pStatic = szError;\n\nWNDCLASSEX stWndClass;\nMSG stMsg;\nHWND hNewWnd;\nRECT rect;\n\nINT nDlgX = 200;\nINT nDlgY = 200;\nINT nDlgW = 160;\nINT nDlgH = 120;\n\nINT nCtrlH = 24;\nINT nStaticX = 10;\nINT nEditX = 50;\nINT nLine1Y = 15;\nINT nLine2Y = 50;\nINT nStaticW = 35;\nINT nEditW = 90;\n\nINT nButtonW = 60;\nINT nButtonY = 50;\nINT nButton1X = 10;\nINT nButton2X = nDlgW - nButtonW - nButton1X*2;\n\nif(FLAG_INPUTDLG_TWOLINE == nFlag){\nnDlgH += (10 + nCtrlH);\nnButtonY += (10 + nCtrlH);\nnStaticW += 35;\nnEditX += 35;\nnDlgW += 35;\nnButton2X += 35;\n}\n\nRtlZeroMemory(&amp;stWndClass,sizeof(stWndClass));\nstWndClass.hCursor = LoadCursor(0,IDC_ARROW);\nstWndClass.hInstance = GetModuleHandle(NULL);\nstWndClass.cbSize = sizeof(WNDCLASSEX);\nstWndClass.style = CS_HREDRAW | CS_VREDRAW;\nstWndClass.lpfnWndProc = (WNDPROC)_ProcInputDlg;\nstWndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\nstWndClass.lpszClassName = pClassName;\n\nRegisterClassEx(&amp;stWndClass);\n\nhInputDlg = CreateWindowEx(WS_EX_CLIENTEDGE,\npClassName,pTitle,/\nWS_OVERLAPPEDWINDOW,/\nnDlgX,nDlgY,nDlgW,nDlgH,/\nNULL,NULL,hInstance,NULL);\n\nif(FLAG_INPUTFLG_GOTO == nInputDlgSts){\npStatic = szGoto;\n}\nelse if(FLAG_INPUTFLG_FIND == nInputDlgSts){\npStatic = szFind;\n}\nelse if(FLAG_INPUTFLG_REPLACE == nInputDlgSts){\npStatic = szFind;\n}\nelse{\n}\nhNewWnd = CreateWindow(TEXT("Static"),pStatic,/\nWS_CHILDWINDOW|WS_VISIBLE|WS_BORDER,/\nnStaticX,nLine1Y,nStaticW,nCtrlH,/\nhInputDlg,(HMENU)CTRL_ID_STATIC,hInstance,NULL);\nShowWindow(hNewWnd,SW_SHOWNORMAL);\n\nhNewWnd = CreateWindow(TEXT("Edit"),TEXT(""),/\nWS_CHILDWINDOW|WS_VISIBLE|WS_BORDER|WS_TABSTOP,/\nnEditX,nLine1Y,nEditW,nCtrlH,/\nhInputDlg,(HMENU)CTRL_ID_EDIT_INPUT,hInstance,NULL);\nSetFocus(hNewWnd);\nShowWindow(hNewWnd,SW_SHOWNORMAL);\n\nif(FLAG_INPUTDLG_TWOLINE == nFlag){\nhNewWnd = CreateWindow(TEXT("Static"),szReplace,/\nWS_CHILDWINDOW|WS_VISIBLE|WS_BORDER,/\nnStaticX,nLine2Y,nStaticW,nCtrlH,/\nhInputDlg,(HMENU)CTRL_ID_STATIC,hInstance,NULL);\nShowWindow(hNewWnd,SW_SHOWNORMAL);\n\nhNewWnd = CreateWindow(TEXT("Edit"),TEXT(""),/\nWS_CHILDWINDOW|WS_VISIBLE|WS_BORDER|WS_TABSTOP,/\nnEditX,nLine2Y,nEditW,nCtrlH,/\nhInputDlg,(HMENU)CTRL_ID_EDIT_REPLACE,hInstance,NULL);\nShowWindow(hNewWnd,SW_SHOWNORMAL);\n}\n\nhNewWnd = CreateWindow(TEXT("Button"),TEXT("&amp;OK"),/\nWS_CHILDWINDOW|WS_VISIBLE|WS_GROUP|WS_TABSTOP,/\nnButton1X,nButtonY,nButtonW,nCtrlH,/\nhInputDlg,(HMENU)CTRL_ID_BTN_INPUT,hInstance,NULL);\nShowWindow(hNewWnd,SW_SHOWNORMAL);\n\nhNewWnd = CreateWindow(TEXT("Button"),TEXT("&amp;Cancel"),/\nWS_CHILDWINDOW|WS_VISIBLE|WS_GROUP|WS_TABSTOP,/\nnButton2X,nButtonY,nButtonW,nCtrlH,/\nhInputDlg,(HMENU)CTRL_ID_BTN_CANCEL,hInstance,NULL);\nShowWindow(hNewWnd,SW_SHOWNORMAL);\n\nShowWindow(hInputDlg,SW_SHOWNORMAL);\nUpdateWindow(hInputDlg);\n\nreturn hInputDlg;\n}\n\nBOOL _PreTranslateMessage(MSG* pMsg)\n{\nBOOL bRet = TRUE;\nif((NULL != hInputDlg)&amp;&amp;(WM_KEYDOWN == pMsg-&gt;message)){\nif((VK_RETURN == pMsg-&gt;wParam)||\n(VK_ESCAPE == pMsg-&gt;wParam)\n){\nSendMessage(hInputDlg,pMsg-&gt;message,pMsg-&gt;wParam,pMsg-&gt;lParam);\n}\nelse if(VK_TAB == pMsg-&gt;wParam){\nOnInputDlgTab();\nbRet = FALSE;\n}\n}\n\nif((GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT) == pMsg-&gt;hwnd)&amp;&amp;\n((WM_KEYUP == pMsg-&gt;message)||(WM_LBUTTONUP == pMsg-&gt;message))){\nOnEditCurMoved();\n}\n\nif(WM_DROPFILES == pMsg-&gt;message){\nSendMessage(hWinMain,pMsg-&gt;message,pMsg-&gt;wParam,pMsg-&gt;lParam);\n}\n\nreturn bRet;\n}\n\nINT _WinMain(VOID)\n{\nMSG stMsg;\nHWND hNewWnd;\nHMENU hMenu;\nHACCEL hAccelerator;\nWNDCLASSEX stWndClass;\n\nhMenu = CreateMainMenu();\nhAccelerator = CreateAccelerator();\nhInstance = GetModuleHandle(NULL);\n\nmemset(&amp;stWndClass,0,sizeof(stWndClass));\nstWndClass.hCursor = LoadCursor(0,IDC_ARROW);\nstWndClass.hInstance = hInstance;\nstWndClass.cbSize = sizeof(WNDCLASSEX);\nstWndClass.style = CS_HREDRAW | CS_VREDRAW;\nstWndClass.lpfnWndProc = (WNDPROC)_ProcWinMain;\nstWndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\nstWndClass.lpszClassName = szClassName;\n\nRegisterClassEx(&amp;stWndClass);\n\nhWinMain = CreateWindowEx(WS_EX_CLIENTEDGE|WS_EX_ACCEPTFILES,/\nszClassName,szCaptionMain,/\nWS_OVERLAPPEDWINDOW,/\n100,100,600,400,/\nNULL,hMenu,hInstance,hAccelerator);\nModifyWinTitle();\n\nhNewWnd = CreateEdit(WS_CHILDWINDOW|WS_VISIBLE|ES_MULTILINE|ES_WANTRETURN|/\nES_AUTOHSCROLL|ES_AUTOVSCROLL|WS_VSCROLL|WS_HSCROLL);\nSetFocus(GetDlgItem(hWinMain,CTRL_ID_EDIT_TEXT));\n\nCreateStatusBar();\n\nOpenGivenFile(cCrtFile);\n\nShowWindow(hWinMain,SW_SHOWNORMAL);\nUpdateWindow(hWinMain);\n\nwhile(TRUE){\n\nif(GetMessage(&amp;stMsg,NULL,0,0)==0){\nbreak;\n}\n\nif(!(TranslateAccelerator(hWinMain,hAccelerator,&amp;stMsg))){\nTranslateMessage(&amp;stMsg);\nif(_PreTranslateMessage(&amp;stMsg)){\nDispatchMessage(&amp;stMsg);\n}\n}\n\n}\n\nreturn 0;\n\n}\n\n/* There is no wmain in mingw 5.1.6 */\n/* I find a "#if 0" in tchar.h , but don''t know why ... */\nINT main(INT argc, TCHAR *argv[ ], CHAR *env[])\n{\nbUndo = FALSE;\nbWantReturn = FALSE;\n\nhInputDlg = NULL;\nhInstance = NULL;\nhWinMain = NULL;\nhWinStatus = NULL;\n\nnInputDlgSts = FLAG_INPUTFLG_NONE;\n\nmemset(cCrtFile,0,sizeof(cCrtFile));\nmemset(cInputEdit,0,sizeof(cInputEdit));\n\nif(argc &gt; 1){\n#ifdef UNICODE\n/* The command line is in ansi format , need convert. */\nINT nSize = _tcslen(argv[1])* sizeof(TCHAR);\nMultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,\n(CHAR*)argv[1],nSize,\ncCrtFile,nSize * sizeof(TCHAR));\n#else\n_tcscpy(cCrtFile,argv[1]);\n#endif\n}\n\n_WinMain();\nExitProcess(0);\n\nreturn 0;\n}\n\nVOID DEBUG_Output(TCHAR* lpszFormat, ...)\n{\n#ifdef DEBUG\nTCHAR tcBuff[MAX_STRING];\nva_list args;\n\nva_start(args, lpszFormat);\n_vstprintf(tcBuff,lpszFormat,args);\nva_end(args);\n\nMessageBox(NULL,tcBuff,TEXT("DEBUG"),MB_OK);\n#endif\n}</pre>\n原文发表于：<a href="http://blog.csdn.net/zeerd">2010-02-12 22:24</a>\nPS：这么长的代码几乎没有注释……汗啊！
