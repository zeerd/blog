---
layout: post
title: 根据/dev/bus/usb在不打开设备的情况下获取USB信息
tags: [Android,Device]
---
在Android中，我们通常在上层只能获取到类似/dev/bus/usb/001/002这样的设备名称。<br>通过这个名称，可以打开设备并且进行相关的操作。<br><br>但是，有时候我们可能因为某些原因无法打开设备。那么，下面的方法可以参考用来获取一些设备信息。<br>
<!--break-->
<br><pre class="brush: c; gutter: true">/* <br> * Refs : ./system/core/fastboot/usb_linux.c:164~181 @ Android<br> * The following comments were copied from this file:<br> * <br> * We need to get a path that represents a particular port on a particular<br> * hub.  We are passed an fd that was obtained by opening an entry under<br> * /dev/bus/usb.  Unfortunately, the names of those entries change each<br> * time devices are plugged and unplugged.  So how to get a repeatable<br> * path?  udevadm provided the inspiration.  We can get the major and<br> * minor of the device file, read the symlink that can be found here:<br> *   /sys/dev/char/&lt;major&gt;:&lt;minor&gt;<br> * and then use the last element of that path.  As a concrete example, I<br> * have an Android device at /dev/bus/usb/001/027 so working with bash:<br> *   $ ls -l /dev/bus/usb/001/027<br> *   crw-rw-r-- 1 root plugdev 189, 26 Apr  9 11:03 /dev/bus/usb/001/027<br> *   $ ls -l /sys/dev/char/189:26<br> *   lrwxrwxrwx 1 root root 0 Apr  9 11:03 /sys/dev/char/189:26 -&gt;<br> *           ../../devices/pci0000:00/0000:00:1a.7/usb1/1-4/1-4.2/1-4.2.3<br> * So our device_path would be 1-4.2.3 which says my device is connected<br> * to port 3 of a hub on port 2 of a hub on port 4 of bus 1 (per<br> * http://www.linux-usb.org/FAQ.html).<br>  * */<br><br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;linux/kdev_t.h&gt;<br><br>typedef struct {<br>	char path[1024];<br>	char product[1024];<br>	char vendor[1024];<br>	char serial[1024];<br>}info_t;<br><br>static int readInfo(const char* from, char* info){<br>	FILE *fp = fopen(from, &quot;r&quot;);<br>	if(fp != NULL){<br>		fscanf(fp, &quot;%s&quot;, info);<br>		fclose(fp);<br>		return 0;<br>	}<br>	return -1;<br>}<br><br>int readInfos(const char* from, info_t* info){<br><br>    struct stat s;<br>    if(lstat(from, &amp;s) &lt; 0) {<br>		printf(&quot;Usage:\\n\\t%s &lt;block path or char path&gt;\\n\\n&quot;, argv[0]);<br>        return -1;<br>    }<br>    <br>    if(((s.st_mode &amp; S_IFMT) == S_IFBLK) <br>    || ((s.st_mode &amp; S_IFMT) == S_IFCHR)){<br>		sprintf(info-&gt;path, <br>			&quot;/sys/dev/char/%d:%d&quot;, <br>			(int) MAJOR(s.st_rdev), (int) MINOR(s.st_rdev));<br>		char readFromFile[1024];<br>		sprintf(readFromFile, &quot;%s/idProduct&quot;, info-&gt;path);<br>		readInfo(readFromFile, info-&gt;product);<br>		sprintf(readFromFile, &quot;%s/idVendor&quot;, info-&gt;path);<br>		readInfo(readFromFile, info-&gt;vendor);<br>		sprintf(readFromFile, &quot;%s/serial&quot;, info-&gt;path);<br>		readInfo(readFromFile, info-&gt;serial);<br>	}<br>	return 0;<br>}<br>    <br>int main(int argc, char **argv)<br>{<br>	if(argc != 2){<br>		printf(&quot;Usage:\\n\\t%s &lt;path&gt;\\n\\n&quot;, argv[0]);<br>	} else {<br>		info_t info;<br>		if(readInfos(argv[1], &amp;info) &lt; 0){<br>			printf(&quot;parameter error!\\n&quot;);<br>		} else {<br>			printf(&quot;path:%s\\nidProduct:%s\\nidVendor:%s\\nSerial:%s\\n&quot;,<br>				argv[1], info.product, info.vendor, info.serial);<br>		}<br>	}<br>	<br>	return 0;<br>}</pre>