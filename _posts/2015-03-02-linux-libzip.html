---
layout: post
title: 基于libzip的简易压缩(zip)/解压缩(unzip)程序
tags: [Linux,Zip,libzip]
---
<!--break-->
简要的提示一下接口调用的流程：<br><br><strong>zip.c</strong><br><pre class="brush: c; gutter: true">/*	zip.c Copyright (c) 2015 zeerd.com.<br> *<br> *  http://opensource.org/licenses/bsd-license.php<br> *<br> *	Compile:<br> *	./configure --prefix=/usr<br> *	make &amp;&amp; sudo make isntall<br> *	gcc zip.c -lzip -o zip<br> *<br> *	Got libzip from http://www.nih.at/libzip<br> */<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;dirent.h&gt;<br>#include &lt;errno.h&gt;<br>#include &lt;sys/stat.h&gt;<br><br>#include &lt;zip.h&gt;<br><br>#define DBG_SEQ 0<br>#define LOGI printf<br>#define LOGD printf<br>#define LOGE printf<br><br>static int root_len = 0;<br>static char path[ PATH_MAX ];<br>static struct zip *z = NULL;<br><br>void search_dir ( const char * name )<br>{<br>	struct stat _stbuf;<br>	<br>	char pathBak[ PATH_MAX ];<br>	strcpy(pathBak, path);<br>	strncat( path, name, sizeof( path ));<br><br>	if (DBG_SEQ) LOGI( &quot;searching %s\\n&quot;, path );<br><br>	if( stat( path, &amp;_stbuf ) == 0 ) {<br><br>		if( S_ISDIR( _stbuf.st_mode )) {<br>			DIR * _dir;<br>			struct dirent * _file;<br>			<br>			_dir	=	opendir( path );<br><br>			if( _dir ) {<br>				<br>				if (DBG_SEQ) LOGD(&quot;find folder %s\\n&quot;, path);<br><br>				//Caution : no need to do this unless there is a empty folder<br>				//zip_dir_add(z, name, ZIP_FL_ENC_GUESS); <br><br>				strncat( path, &quot;/&quot;, sizeof( path ));<br><br>				while(( _file = readdir( _dir )) != NULL ) {<br>					if( strncmp( _file-&gt;d_name, &quot;.&quot;, 1 ) != 0 ) {<br>						search_dir( _file-&gt;d_name);<br>					}<br>				}<br><br>				closedir( _dir );<br>			}<br>			else {<br>				LOGE( &quot;open dir failed: %s\\n&quot;, path );<br>			}<br>		}<br>		else {<br>			if (DBG_SEQ) LOGD(&quot;find file %s\\n&quot;, path);<br><br>			struct zip_source *s = zip_source_file(z, path, 0, -1);<br>			if(s != NULL) {<br>				// the file name give to zip_file_add() would include the path<br>				zip_file_add(z, &amp;path[root_len+1], s,<br>					ZIP_FL_OVERWRITE|ZIP_FL_ENC_GUESS);<br><br>				//would be used and freed by zip_close(),<br>				//so don&#039;t free the zip_source here.<br>				//zip_source_free(s); <br>			} else {<br>				LOGE( &quot;zip_source_file failed for %s with the reason %s\\n&quot;,<br>					path, zip_strerror(z) );<br>			}<br>		}<br>	}<br>	else {<br>		LOGE( &quot;stat failed\\n&quot; );<br>	}<br><br>	/* remove parsed name */<br>	strcpy(path, pathBak);<br>}<br><br><br>int main(int argc, char *argv[])<br>{<br>	int err = 0;<br>	char strerr[1024];<br><br>	if (argc &lt; 3) {<br>		printf(<br>			&quot;\\nArchive a folder to a zip file.\\n&quot;<br>			&quot;Usage:\\n\\t%s &lt;path&gt; &lt;zip&gt;\\n&quot;<br>			&quot;Example:\\n\\t%s /home/foo/foo /home/foo/foo.zip\\n\\n&quot;,<br>			argv[0], argv[0]);<br>		return -1;<br>	}<br><br>	root_len = strlen(argv[1]);<br>	z = zip_open(argv[2], ZIP_CREATE|ZIP_EXCL, &amp;err);<br><br>	if (z != NULL) {<br>		search_dir(argv[1]);<br>		err = zip_close(z);<br>    } <br><br>    if (err != 0) {<br>    	zip_error_to_str(strerr, 1024, err, errno);<br>    	LOGE(&quot;operated zip fail for %s\\n&quot;, strerr);<br>    }<br><br>	return 0;<br>}<br></pre><br><strong>unzip.c</strong><br><pre class="brush: c; gutter: true">/*	unzip.c Copyright (c) 2015 zeerd.com.<br> *<br> *  http://opensource.org/licenses/bsd-license.php<br> *<br> *	Compile:<br> *	./configure --prefix=/usr<br> *	make &amp;&amp; sudo make isntall<br> *	gcc unzip.c -lzip -o unzip<br> *<br> *	Got libzip from http://www.nih.at/libzip<br> */<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;dirent.h&gt;<br>#include &lt;errno.h&gt;<br>#include &lt;sys/stat.h&gt;<br><br>#include &lt;zip.h&gt;<br><br>#define DBG_SEQ 0<br>#define LOGI printf<br>#define LOGD printf<br>#define LOGE printf<br><br>int pmkdir(const char *path) <br>{ <br>	char name[ PATH_MAX ]; <br>	strcpy(name, path); <br>	int i, len = strlen(name); <br><br>	if (name[len-1]!=&#039;/&#039;) {<br>		strcat(name, &quot;/&quot;);<br>	} <br><br>	len = strlen(name); <br><br>	for (i=1 ; i&lt;len ; i++) { <br>		if (name[i]==&#039;/&#039;) { <br>			name[i] = 0; <br>			if ( access(name, NULL) !=0 ) { <br>				if (mkdir(name, 0755) == -1) {  <br>					LOGE(&quot;mkdir error&quot;);  <br>					return -1;  <br>				} <br>			}<br>			name[i] = &#039;/&#039;; <br>		} <br>	} <br><br>	return 0; <br>} <br><br>int main(int argc, char *argv[])<br>{<br>	int err = 0;<br>	char strerr[1024];<br>	struct zip *z = NULL;<br><br>	if (argc &lt; 2) {<br>		printf(<br>			&quot;\\nUn-Archive a zip file to the current path.\\n&quot;<br>			&quot;Usage:\\n\\t%s &lt;zip&gt;\\n&quot;<br>			&quot;Example:\\n\\t%s foo.zip\\n\\n&quot;,<br>			argv[0], argv[0]);<br>		return -1;<br>	}<br><br>	z = zip_open(argv[1], ZIP_CREATE, &amp;err);<br>	if (z != NULL) {<br><br>		zip_int64_t i, c = zip_get_num_entries(z, ZIP_FL_UNCHANGED);<br>		for (i=0; i&lt;c ; i++) {<br>			const char * name = zip_get_name(z, i, ZIP_FL_ENC_GUESS);<br>			LOGI(&quot;find %s\\n&quot;, name);<br>			char *d = strdup(name);<br>			if (d != NULL) {<br>				char *p = strrchr(d, &#039;/&#039;);<br>				if(p != NULL) {<br>					*p = &#039;\\0&#039;;<br>					pmkdir(d);<br>				}<br>				free(d);<br><br>				FILE *fp = fopen(name, &quot;w+b&quot;);<br>				struct zip_file *f = zip_fopen(z, name, 0);<br>				if (f != NULL &amp;&amp; fp != NULL) {<br>					zip_int64_t j, n = 0;<br>					char buf[8192] = &quot;&quot;;<br>					while ((n = zip_fread(f, buf, sizeof(buf))) &gt; 0) {<br>						for (j=0;j&lt;n;j++) {<br>							putc(buf[j], fp);<br>						}<br>					}<br>					fclose(fp);<br>					zip_fclose(f);<br>				}<br>			} else {<br>				LOGE(&quot;memory low\\n&quot;);<br>			}<br>		}<br><br>		err = zip_close(z);<br>	} else {<br>		zip_error_to_str(strerr, 1024, err, errno);<br>		LOGE(&quot;operated zip fail for %s\\n&quot;, strerr);<br>	}<br><br>	return 0;<br>}</pre>