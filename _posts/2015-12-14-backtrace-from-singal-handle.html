---
layout: post
title: 通过截取signal输出程序崩溃时的backtrace
tag: [Linux,Debug,Backtrace]
---
主要是参考了Android的实现方法。做成了一个简单的lib库。
<!--break-->
如下所示：<br><br>lib.c<br><pre class="brush: c; gutter: true">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>#include &lt;signal.h&gt;<br><br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/prctl.h&gt;<br>#include &lt;sys/syscall.h&gt;<br><br>#include &lt;unistd.h&gt;<br><br>#include &lt;execinfo.h&gt;<br><br>#define ALOGE(...) ((void)fprintf(stderr, __VA_ARGS__))<br><br>#define BT_DEPTH 30<br><br>static void dbg_signal_handler(int n, siginfo_t* info, void* unused)<br>{<br><br>    char threadname[1024 + 1]; // one more for termination<br>    char* signame;<br>    switch (n) {<br>        case SIGILL:    signame = &quot;SIGILL&quot;;     break;<br>        case SIGABRT:   signame = &quot;SIGABRT&quot;;    break;<br>        case SIGBUS:    signame = &quot;SIGBUS&quot;;     break;<br>        case SIGFPE:    signame = &quot;SIGFPE&quot;;     break;<br>        case SIGSEGV:   signame = &quot;SIGSEGV&quot;;    break;<br>        case SIGSTKFLT: signame = &quot;SIGSTKFLT&quot;;  break;<br>        case SIGPIPE:   signame = &quot;SIGPIPE&quot;;    break;<br>        default:        signame = &quot;???&quot;;        break;<br>    }<br><br>    if (prctl(PR_GET_NAME, (unsigned long)threadname, 0, 0, 0) != 0) {<br>        strcpy(threadname, &quot;&lt;name unknown&gt;&quot;);<br>    } else {<br>        // short names are null terminated by prctl, but the manpage<br>        // implies that 16 byte names are not.<br>        threadname[1024] = 0;<br>    }<br><br>    ALOGE(<br>        &quot;[LIB] Fatal signal %d (%s) at %p (code=%d), thread %ld (%s)\\n&quot;,<br>        n, signame, info-&gt;si_addr, info-&gt;si_code, syscall(SYS_gettid), threadname);<br><br><br>    void * _array[BT_DEPTH];<br>    size_t _size;<br>    char ** _strings;<br>    int i;<br><br>    _size = backtrace(_array, BT_DEPTH);<br>    _strings = backtrace_symbols(_array, _size);<br><br>    if(_strings != NULL) {<br><br>        ALOGE(&quot;[LIB] stack depth %ld\\n&quot;, _size);<br>        for(i = 0; i &lt; _size; i ++) {<br>            ALOGE(&quot;[LIB] %s\\n&quot;, _strings[i]);<br>        }<br><br>        free(_strings);<br>    }<br><br>    /* remove our net so we fault for real when we return */<br>    signal(n, SIG_DFL);<br><br>    /*<br>     * These signals are not re-thrown when we resume.  This means that<br>     * crashing due to (say) SIGPIPE doesn&#039;t work the way you&#039;d expect it<br>     * to.  We work around this by throwing them manually.  We don&#039;t want<br>     * to do this for *all* signals because it&#039;ll screw up the address for<br>     * faults like SIGSEGV.<br>     */<br>    switch (n) {<br>        case SIGABRT:<br>        case SIGFPE:<br>        case SIGPIPE:<br>        case SIGSTKFLT:<br>            (void) syscall(SYS_tgkill, getpid(), syscall(SYS_gettid), n);<br>            break;<br>        default:    // SIGILL, SIGBUS, SIGSEGV<br>            break;<br>    }<br>}<br><br>void dbg_init(void)<br>{<br>    struct sigaction act;<br>    memset(&amp;act, 0, sizeof(act));<br>    act.sa_sigaction = dbg_signal_handler;<br>    act.sa_flags = SA_RESTART | SA_SIGINFO;<br>    sigemptyset(&amp;act.sa_mask);<br>    sigaction(SIGILL, &amp;act, NULL);<br>    sigaction(SIGABRT, &amp;act, NULL);<br>    sigaction(SIGBUS, &amp;act, NULL);<br>    sigaction(SIGFPE, &amp;act, NULL);<br>    sigaction(SIGSEGV, &amp;act, NULL);<br>    sigaction(SIGSTKFLT, &amp;act, NULL);<br>    sigaction(SIGPIPE, &amp;act, NULL);<br>}</pre><br>&nbsp;<br><br>然后，每次做成可执行文件时，在main函数的最开始调用dbg_init()函数，加入backtrace输出功能。<br><br>crash.c<br><pre class="brush: actionscript3; gutter: true">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>extern void dbg_init(void);<br><br>int *d = (int*)1;<br><br>int c(void)<br>{<br>    return *d;<br>}<br><br>int b(void)<br>{<br>    return c();<br>}<br><br>int a(void)<br>{<br>    return b();<br>}<br><br>int main(int argc, char *argv[])<br>{<br>    dbg_init();<br><br>    printf(&quot;[TEST] pid = %d\\n&quot;, getpid());<br><br>    return a();<br>}</pre><br>执行的效果如下：<br><pre class="brush: text; gutter: true">root@ubuntu:~/codes/dbg# LD_LIBRARY_PATH=. ./crash<br>[TEST] pid = 24362<br>[LIB] Fatal signal 11 (SIGSEGV) at 0x1 (code=1), thread 24362 (crash)<br>[LIB] stack depth 8<br>[LIB] ./libdbg.so(+0xbfc) [0x7fd4c2560bfc]<br>[LIB] /lib/x86_64-linux-gnu/libc.so.6(+0x370b0) [0x7fd4c21ce0b0]<br>[LIB] ./crash(c+0xb) [0x4008b7]<br>[LIB] ./crash(b+0x9) [0x4008c4]<br>[LIB] ./crash(a+0x9) [0x4008cf]<br>[LIB] ./crash(main+0x34) [0x400905]<br>[LIB] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf5) [0x7fd4c21b8ea5]<br>[LIB] ./crash() [0x4007e9]<br>Segmentation fault</pre><br>而且，由于在lib库中，dbg_signal_handler()函数的最后，将signal的钩子还原了。当这个程序作为其他程序的子进程启动时，父进程还是可以接收到正常的signal信息。<br><br>main.c<br><br>&nbsp;<br><pre class="brush: c; gutter: true">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>#include &lt;errno.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;signal.h&gt;<br><br>#include &lt;sys/types.h&gt;<br><br>static int quit = 0;<br><br>static void sig_chld( int signo )<br>{<br><br>    pid_t id;<br>    int stat;<br>    id = wait(&amp;stat);<br><br>    printf(&quot;[MAIN] caught signal %d for pid(%d).\\n&quot;, (WIFSIGNALED(stat) ? WTERMSIG(stat) : -1), id);<br><br>    quit = -1;<br><br>    return;<br>}<br><br>int main(int argc, char *argv[])<br>{<br>    signal(SIGCHLD, sig_chld);<br><br>    if(fork() == 0){<br><br>        char * const cmds[] = {<br>            [0] = argv[1],<br>            [1] = NULL<br>        };<br><br>        execv(cmds[0], cmds);<br>    }<br><br>    while(!quit) {usleep(100);}<br><br>    return 0;<br>}</pre><br>&nbsp;<br><br>最后，提供一下Makefile文件，说明一下依赖的编译参数。其中需要注意的是，可执行程序编译时必须附带“-rdynamic”参数。<br><pre class="brush: text; gutter: true">all: crash main<br><br>lib:<br>	@gcc lib.c -o libdbg.so -O0 -g -shared -fPIC<br><br>crash: lib<br>	@gcc crash.c -o crash -O0 -g -rdynamic -ldbg -L.<br><br>main:<br>	@gcc main.c -o main -O0 -g<br><br>test: all<br>	@LD_LIBRARY_PATH=. ./main ./crash<br><br>clean:<br>	@-rm crash main libdbg.so core</pre><br>执行的测试结果：<br><pre class="brush: text; gutter: true">root@ubuntu:~/codes/dbg# make test<br>[TEST] pid = 24401<br>[LIB] Fatal signal 11 (SIGSEGV) at 0x1 (code=1), thread 24401 (crash)<br>[LIB] stack depth 8<br>[LIB] ./libdbg.so(+0xbfc) [0x2b582e3c0bfc]<br>[LIB] /lib/x86_64-linux-gnu/libc.so.6(+0x370b0) [0x2b582e6090b0]<br>[LIB] ./crash(c+0xb) [0x4008b7]<br>[LIB] ./crash(b+0x9) [0x4008c4]<br>[LIB] ./crash(a+0x9) [0x4008cf]<br>[LIB] ./crash(main+0x34) [0x400905]<br>[LIB] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf5) [0x2b582e5f3ea5]<br>[LIB] ./crash() [0x4007e9]<br>[MAIN] caught signal 11 for pid(24401).</pre>