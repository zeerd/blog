---
layout: post
title: 利用taglib和sqlite实现简易的媒体数据库
tag: [TagLib,Sqlite]
---
现在的各种媒体播放器及用户，已经不再满足于仅将文件系统中的目录结构罗列出来以供听众选择的传统操作方式了。越来越多的媒体播放器开始支持按着演唱者（artist）、专辑名称（album）来进行歌曲的归类和播放。<br><br>
<!--break-->
下面的内容，是我参照Banshee的数据库结构进行删改之后，生成的一个简单的媒体数据库生成和查询的例子。<br><br>可以实现简单的数据库建立以及分类查找。<br><br>&nbsp;<br><br>首先是一个针对媒体文件内tag信息的解析过程。这个过程使用taglib实现。我没有自己写太多的代码，直接拿来taglib的examples中的framelist.cpp来进行修改。主要是修改了输出格式。另外，原本taglib中附带的例子没有专辑图片（artwork）的读取部分。我参照taglib的源代码，企图使用attachedpictureframe类进行图片的读取。但是不知道什么原因，这个类读出来的图片（picture()函数）的大小是错误的，在我的试验中仅能生成1/3的图片。所以，我自己根据APIC的格式写了一个简单的读取处理。<br><br><strong><span style="line-height: 1.5;">tagreader.cpp</span></strong><br><br><pre class="brush: cpp; gutter: true; first-line: 1; highlight: []; html-script: false"><br>/* Copyright (C) 2003 Scott Wheeler &lt;wheeler@kde.org&gt;<br> *<br> * Redistribution and use in source and binary forms, with or without<br> * modification, are permitted provided that the following conditions<br> * are met:<br> *<br> * 1. Redistributions of source code must retain the above copyright<br> *    notice, this list of conditions and the following disclaimer.<br> * 2. Redistributions in binary form must reproduce the above copyright<br> *    notice, this list of conditions and the following disclaimer in the<br> *    documentation and/or other materials provided with the distribution.<br> *<br> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#039;&#039; AND ANY EXPRESS OR<br> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES<br> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.<br> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,<br> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT<br> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,<br> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY<br> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF<br> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br> */<br><br>#include &lt;iostream&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;stdio.h&gt;<br><br>#include &lt;taglib/tbytevector.h&gt;<br><br>#include &lt;taglib/mpegfile.h&gt;<br><br>#include &lt;taglib/id3v2tag.h&gt;<br>#include &lt;taglib/id3v2frame.h&gt;<br>#include &lt;taglib/id3v2header.h&gt;<br><br>#include &lt;taglib/id3v1tag.h&gt;<br><br>#include &lt;taglib/apetag.h&gt;<br>#include &lt;taglib/attachedpictureframe.h&gt;<br><br><br>using namespace std;<br>using namespace TagLib;<br><br>int main(int argc, char *argv[])<br>{<br>  // process the command line args<br>  char szTitle[256]=&quot;&quot;;<br>  char szAlbum[256]=&quot;&quot;;<br>  char szArtist[256]=&quot;&quot;;<br>  char szArtwork[256]=&quot;&quot;;<br><br>  for(int i = 1; i &lt; argc; i++) {<br><br>    MPEG::File f(argv[i]);<br><br>    ID3v2::Tag *id3v2tag = f.ID3v2Tag();<br><br>    if(id3v2tag) {<br><br>      ID3v2::FrameList::ConstIterator it = id3v2tag-&gt;frameList().begin();<br>      for(; it != id3v2tag-&gt;frameList().end(); it++){<br>        if(id3v2tag-&gt;header()-&gt;majorVersion()==3 &amp;&amp; id3v2tag-&gt;header()-&gt;revisionNumber()==0){<br>          if ((*it)-&gt;frameID() == &quot;TIT2&quot;){<br>            strcpy(szTitle, (*it)-&gt;toString().toCString());<br>          }<br>          if ((*it)-&gt;frameID() == &quot;TPE1&quot;){<br>            strcpy(szArtist, (*it)-&gt;toString().toCString());<br>          }<br>          if ((*it)-&gt;frameID() == &quot;TALB&quot;){<br>            strcpy(szAlbum, (*it)-&gt;toString().toCString());<br>          }<br>          if ((*it)-&gt;frameID() == &quot;APIC&quot;){<br>            ID3v2::AttachedPictureFrame *apf =<br>              static_cast&lt;TagLib::ID3v2::AttachedPictureFrame*&gt;(id3v2tag-&gt;frameListMap()[&quot;APIC&quot;].front());<br>            if(apf != NULL){<br>              char pic_file[256]=&quot;&quot;;<br>              strcpy(pic_file,  argv[i]);<br>              strcat(pic_file, &quot;.&quot;);<br>              strcat(pic_file, strchr( apf-&gt;mimeType().toCString(), &#039;/&#039;)+1);<br>              FILE *out = fopen(pic_file, &quot;w&quot;);<br>              if(out != NULL){<br>                for(int i=0;i&lt;apf-&gt;picture().size() ;i++){<br>                  fprintf(out, &quot;%c&quot;, apf-&gt;picture().at(i) );<br>                }<br>                fclose(out);<br>              }<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br><br>  cout &lt;&lt; szTitle &lt;&lt; &quot; &quot; &lt;&lt; szArtist &lt;&lt; &quot; &quot; &lt;&lt; szAlbum &lt;&lt; &quot; &quot; &lt;&lt; szArtwork &lt;&lt; endl;<br>}<br><br></pre><br><br>接下来这个文件是一个shell脚本。实现了数据库的创建、文件结构解析、数据库登录、查询的最基本的简单功能。<br>本来打算用C/C++来写，但实在是没有太多的linux开发经验，一时也不知道去哪里翻看linux下的文件系统相关的库函数。所以就偷懒使用shell脚本编写了。反正就是一个例子，也不需要多高的执行效率之类的。<br><br><strong>tagreader.sh</strong><br><pre class="brush: bash; gutter: true">#!/bin/bash<br>#<br><br>SQLITE_CMD=sqlite3<br>DB_NAME=test.db<br>CC=g++<br>TAG_READER=./tagreader<br><br>folder_cnt=0<br>track_id_idx=0<br>artist_id_idx=-1<br><br>#<br><br># 在这里创建了数据库结构。结构很简单，我就不画图了。直接看吧。<br>function create_db(){<br>  echo --- creating database ---<br>  $SQLITE_CMD $DB_NAME &quot;Create TABLE coretracks (track_id INTEGER PRIMARY KEY, album_id INTEGER, artist_id INTEGER, folder_id INTEGER, title TEXT, file_name TEXT, uri_path TEXT, uri_artwork TEXT);&quot;<br>  $SQLITE_CMD $DB_NAME &quot;Create TABLE corealbums (album_id INTEGER PRIMARY KEY, artist_id INTEGER, title TEXT, artist_name TEXT, uri_artwork TEXT);&quot;<br>  $SQLITE_CMD $DB_NAME &quot;Create TABLE coreartists (artist_id INTEGER PRIMARY KEY, name TEXT);&quot;<br>  $SQLITE_CMD $DB_NAME &quot;Create TABLE corefolders (folder_id INTEGER PRIMARY KEY, name TEXT, parent_id INTEGER);&quot;<br>}<br><br># 这个函数用来递归解析给定的路径及其子路径下的媒体文件。这里为了简化流程，仅对扩展名为mp3的文件进行了解析。<br># 函数传入了四个参数，分别是：当前路径（绝对路径）、将要进入的子路径名称、当前已经计数到的folder id、父路径的folder id<br>function cntsana(){<br>  local full_working_folder=$1&quot;/&quot;$2<br>  local current_folder=$2<br>  local folder_id_idx=$[$3+1]<br>  local parent_folder_id=$4<br>  folder_cnt=$[$folder_cnt+1]<br>  $SQLITE_CMD $DB_NAME &quot;insert into corefolders values( $folder_cnt, \\&quot;$current_folder\\&quot;, $parent_folder_id);&quot;<br>  for file in `ls $full_working_folder -A`<br>  do<br>    if [ -d $full_working_folder&quot;/&quot;$file ]<br>    then<br>      cntsana $full_working_folder $file $folder_cnt $folder_id_idx<br>    else<br>      local path=$full_working_folder&quot;/&quot;$file<br>      local name=$file<br>      ext=${path##*.}<br>      if [[ $ext == &quot;mp3&quot; ]];then<br>        # 调用前面的cpp程序进行tag解析<br>        tag_string=(`$TAG_READER $path`)<br>        title=${tag_string[0]}<br>        artist=${tag_string[1]}<br>        album=${tag_string[2]}<br>        artwork=${tag_string[3]}<br>        sql_result=`$SQLITE_CMD $DB_NAME &quot;select count() from coreartists where name=\\&quot;$artist\\&quot;;&quot;`<br>        if [[ $sql_result == 0 ]];then<br>          artist_cnt=`$SQLITE_CMD $DB_NAME &quot;select count() from coreartists;&quot;`<br>          artist_id_idx=$[$artist_cnt+1]<br>          sql_result=`$SQLITE_CMD $DB_NAME &quot;insert into coreartists values( $artist_id_idx, \\&quot;$artist\\&quot;);&quot;`<br>        else<br>          artist_id_idx=`$SQLITE_CMD $DB_NAME &quot;select artist_id from coreartists where name=\\&quot;$artist\\&quot;;&quot;`<br>        fi<br><br>        sql_result=`$SQLITE_CMD $DB_NAME &quot;select count() from corealbums where title=\\&quot;$album\\&quot; and artist_name=\\&quot;$artist\\&quot;;&quot;`<br>        if [[ $sql_result == 0 ]];then<br>          album_cnt=`$SQLITE_CMD $DB_NAME &quot;select count() from corealbums;&quot;`<br>          album_id_idx=$[$album_cnt+1]<br>          sql_result=`$SQLITE_CMD $DB_NAME &quot;insert into corealbums values( $album_id_idx, $artist_id_idx, \\&quot;$album\\&quot;, \\&quot;$artist\\&quot;, \\&quot;$artwork\\&quot;);&quot;`<br>        else<br>          album_id_idx=`$SQLITE_CMD $DB_NAME &quot;select album_id from corealbums where title=\\&quot;$album\\&quot; and artist_name=\\&quot;$artist\\&quot;;&quot;`<br>        fi<br><br>        $SQLITE_CMD $DB_NAME &quot;insert into coretracks values( $track_id_idx, $album_id_idx, $artist_id_idx, $folder_id_idx, \\&quot;$title\\&quot;, \\&quot;$name\\&quot;,  \\&quot;$path\\&quot;, \\&quot;$artwork\\&quot;);&quot;<br>        track_id_idx=$[$track_id_idx+1]<br>      fi<br>    fi<br>  done<br>}<br><br># 以tag为基准进行的媒体查询函数<br>function tag_list(){<br>  local artist_list=(`$SQLITE_CMD $DB_NAME &quot;select name from coreartists;&quot;`)<br>  local artist_cnt=${#artist_list[@]}<br>  for i in $( seq 1 ${artist_cnt} )<br>  do<br>    echo $i -- ${artist_list[i-1]}<br>  done<br>  echo -n &quot;Please choose the artist:&quot;<br>  read chosen_artist_idx<br>  echo You are chosen the ${artist_list[$chosen_artist_idx-1]} ...<br>  chosen_artist_id=`$SQLITE_CMD $DB_NAME &quot;select artist_id from coreartists where name=\\&quot;${artist_list[$chosen_artist_idx-1]}\\&quot;;&quot;`<br><br>  local album_list=(`$SQLITE_CMD $DB_NAME &quot;select title from corealbums where artist_name=\\&quot;${artist_list[$chosen_artist_idx-1]}\\&quot;;&quot;`)<br>  local album_cnt=${#album_list[@]}<br>  for i in $( seq 1 ${album_cnt} )<br>  do<br>    echo $i -- ${album_list[i-1]}<br>  done<br>  echo -n &quot;Please choose the album:&quot;<br>  read chosen_album_idx<br>  echo You are chosen the ${album_list[$chosen_album_idx-1]} ...<br>  chosen_album_id=`$SQLITE_CMD $DB_NAME &quot;select album_id from corealbums where artist_name=\\&quot;${artist_list[$chosen_artist_idx-1]}\\&quot; and title=\\&quot;${album_list[$chosen_album_idx-1]}\\&quot;;&quot;`<br><br>  local track_list=(`$SQLITE_CMD $DB_NAME &quot;select title from coretracks where artist_id=$chosen_artist_id and album_id=$chosen_album_id;&quot;`)<br>  local track_cnt=${#track_list[@]}<br>  for i in $( seq 1 ${track_cnt} )<br>  do<br>    echo $i -- ${track_list[i-1]}<br>  done<br>  echo -n &quot;Please choose the track:&quot;<br>  read chosen_track_idx<br>  local track_path_list=(`$SQLITE_CMD $DB_NAME &quot;select uri_path from coretracks where artist_id=$chosen_artist_id and album_id=$chosen_album_id;&quot;`)<br>  echo You are choosing the \\&quot;${track_list[$chosen_track_idx-1]}\\&quot; of the album \\&quot;${album_list[$chosen_album_idx-1]}\\&quot; singing by \\&quot;${artist_list[$chosen_artist_idx-1]}\\&quot; in the filesystem \\&quot;${track_path_list[$chosen_track_idx-1]}\\&quot;.<br>}<br><br># 传统的，以文件系统结构为基准进行的媒体查询函数<br>function folderfile_list(){<br>  local chosen_folder_id=-1<br>  local chosen_parent_id=1<br>  while ([[ $folder_chosen_idx != 0 ]])<br>  do<br>    local folder_list=(`$SQLITE_CMD $DB_NAME &quot;select name from corefolders where parent_id=$chosen_parent_id;&quot;`)<br>    local folder_cnt=${#folder_list[@]}<br>    if [[ $folder_cnt != 0 ]];then<br>      echo 0 -- show file list<br>      for i in $( seq 1 ${folder_cnt} )<br>      do<br>        echo $i -- ${folder_list[i-1]}<br>      done<br>      echo x -- back to parent<br>      echo -n &quot;Please choose the folder:&quot;<br>      read folder_chosen_idx<br>      if [[ $folder_chosen_idx == &quot;x&quot; ]];then<br>        echo You are chosen to back to parent ...<br>        chosen_folder_id=`$SQLITE_CMD $DB_NAME &quot;select parent_id from corefolders where folder_id=$chosen_parent_id;&quot;`<br>        chosen_parent_id=$chosen_folder_id<br>      elif [[ $folder_chosen_idx != 0 ]];then<br>        echo You are chosen the ${folder_list[$folder_chosen_idx-1]} ...<br>        chosen_folder_id=`$SQLITE_CMD $DB_NAME &quot;select folder_id from corefolders where name=\\&quot;${folder_list[$folder_chosen_idx-1]}\\&quot;;&quot;`<br>        chosen_folder_name=${folder_list[$folder_chosen_idx-1]}<br>        chosen_parent_id=$chosen_folder_id<br>      fi<br>    else<br>      break<br>    fi<br>  done<br><br>  track_list=(`$SQLITE_CMD $DB_NAME &quot;select file_name from coretracks where folder_id=$chosen_folder_id;&quot;`)<br>  track_cnt=${#track_list[@]}<br>  for i in $( seq 1 ${track_cnt} )<br>  do<br>    echo $i -- ${track_list[i-1]}<br>  done<br>  echo -n &quot;Please choose the file:&quot;<br>  read chosen_track_idx<br>  track_path_list=(`$SQLITE_CMD $DB_NAME &quot;select uri_path from coretracks where folder_id=$chosen_folder_id;&quot;`)<br>  echo You are choosing the \\&quot;${track_list[$chosen_track_idx-1]}\\&quot; of the folder \\&quot;$chosen_folder_name\\&quot; in the filesystem \\&quot;${track_path_list[$chosen_track_idx-1]}\\&quot;.<br>}<br><br>#main<br>if [[ ! -f $TAG_READER ]];then<br>  $CC tagreader.c -L/usr/local/lib -ltag -o $TAG_READER<br>fi<br><br>if [[ -f $DB_NAME ]];then<br>  rm -f $DB_NAME<br>fi<br>create_db<br><br>work_root_path=$1<br>if [[ $work_root_path == &quot;&quot; ]];then<br>  work_root_path=`pwd`<br>else<br>  if [[ ${work_root_path:0:1} != &quot;/&quot; &amp;&amp; ${work_root_path:0:1} != &quot;~&quot; ]];then<br>    work_root_path=`pwd`/$work_root_path<br>  fi<br>fi<br><br>cntsana $work_root_path &quot;.&quot; 0 0<br><br>echo 1 -- tag list<br>echo 2 -- folderfile list<br>echo x -- exit<br>echo -n &quot;Please choose the list type:&quot;<br>read list_type_idx<br>if [[ $list_type_idx == 1 ]];then<br>  tag_list<br>elif [[ $list_type_idx == 2 ]];then<br>  folderfile_list<br>fi<br></pre><br><br>以上都是很简单的函数实现，我就不多做解释了。希望能对读者有所帮助。
