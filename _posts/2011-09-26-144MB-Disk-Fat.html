---
layout: post
title: 1.44MB 软盘镜像文件FDT/FAT简析
tags: [Fat]
---
准备：<br>1、一张干净的1.44MB软盘，使用windows98附带的Dos进行完全格式化；<br>2、使用sys命令向磁盘传送系统文件；<br>3、立刻将磁盘做成镜像（保证磁盘的“干净”）。<br><br>FAT12的结构网上有很多，这里不进行累述。<br>下面是针对镜像文件进行的数据分析（下面提到的地址范围只指用UE等打开之后看到的地址）。<br><br>0面0道第2扇区到第10扇区的9个扇区是FAT表的存放位置<br><br>FAT地址范围：0x0200 ~ 0x13FF<br><br>0面0道的第11扇区到1面0道第1扇区的9个扇区是第2个FAT表的存放位置，这第2个FAT是备用的<br>备份FAT地址范围：0x1400 ~ 0x25FF<br><br>1面0道的第2扇区起到1面0道的第15扇区（共14个扇区）用于存放 FDT。<br>FDT起始地址：0x2600 ~ 0x41FF<br><br>以IO.SYS为例：<br>0x2600~0x260A ：文件名<br>0x260B：07：只读、隐藏的系统文件<br>0x260C~0x2615：保留<br>0x2616~0x2617：20A0=0xA020(10100 000001 00000)：文件最后修改时间20:01:00<br>0x2618~0x2619：D324=0x24D3(0010010 0110 10011)：文件最后修改日期1998/06/19<br>0x261A~0x261B：0200：文件首簇号002，其他附后<br>0x261C~0x261F：966B0300=0x00036B96：文件的长度224150Byte<br><br>文件簇号分析：<br>其中，簇号0x002可知：<br>逻辑扇区号 = 0x002+31 = 33<br>因此，IO.SYS文件的存储起始位置为：逻辑扇区号 * 512 = 0x04200<br>文件首簇号002指向的位置为：0x200+(0x002*3/2)=0x200+3=0x203+0（簇号从0x203开始）。<br>因为0能被3整除（姑且这样认为），因此，簇号002指向的位置为0x203+0=0x203的位置。<br>0x203位置的数据为034000=0x004003，即第二簇为003<br><br>以MSDOS.SYS为例：<br>文件首簇号0x23F，可知：<br>逻辑扇区号 = 0x23F+31 = 606<br>因此，MSDOS.SYS文件的存储起始位置为：逻辑扇区号 * 512 = 0x4BC00<br>文件首簇号23F指向的位置为：0x200+(0x23F*3/2)=0x200+862.5=0x203+859.5。<br>因为858能被3整除，因此，簇号23F指向的位置为0x203+858=0x55D后面的1.5个位置。<br>0x55D位置的数据为FFFFFF=0xFFFFFF，因此簇号23F指向的内容为高12bit的0xFFF。<br>即MSDOS.SYS的第一簇为文件的最后一簇。<br><br>FAT12文件系统FDT读取类（简版）<br>目前的版本，仅支持对根目录的文件表进行读取。子目录下面的没研究……<br><br><pre class="brush: cpp; gutter: true">#ifndef _MYFDT_H_<br>#define _MYFDT_H_<br><br>typedef unsigned char U8;<br>typedef unsigned short int U16;<br>typedef unsigned long int U32;<br><br>typedef U8 Type_FDTIndex;<br><br>typedef struct{<br>	U16 u16Year;<br>	U8 u8Month;<br>	U8 u8Day;<br>}MyDate_st;<br><br>typedef struct{<br>	U8 u8Hour;<br>	U8 u8Minute;<br>	U8 u8Second;<br>}MyTime_st;<br><br>class CMyFDT{<br><br>protected:<br><br>#define FDT_START_ADDR (0x2600U)<br>#define FDT_END_ADDR (0x41FFU)<br><br>#define FDT_INFO_LENGTH (32U)<br>#define FDT_INDEX_MAX ((Type_FDTIndex)((FDT_END_ADDR-FDT_START_ADDR+1U)/FDT_INFO_LENGTH))<br><br>	typedef struct{<br>		TCHAR tcFileName[9];<br>		TCHAR tcExtName[4];<br>		U8 u8Ability;<br>		U8 u8NoUse[11];<br>		U16 u16ModifyTime;<br>		U16 u16ModifyDate;<br>		U16 u16FisrtCluster;<br>		U32 u32FileLength;<br>	}MyFDTElement_st;<br><br>	MyFDTElement_st m_FDT[FDT_INDEX_MAX];<br>	Type_FDTIndex m_IndexCnt;<br><br>public:<br>	CMyFDT();<br>	BOOL LoadFDTInfo(TCHAR u8File_p[]);// 参数为磁盘镜像文件首地址<br>	Type_FDTIndex GetIndexCnt();<br>	TCHAR *GetFileName(Type_FDTIndex uIndex,TCHAR *u8FileName_p=NULL);<br>	TCHAR *GetExtName(Type_FDTIndex uIndex,TCHAR *u8ExtName_p=NULL);<br>	BOOL GetFileExist(Type_FDTIndex uIndex);<br>	U8 GetAbility(Type_FDTIndex uIndex);<br>	void GetModifyDate(Type_FDTIndex uIndex,MyDate_st *);<br>	void GetModifyTime(Type_FDTIndex uIndex,MyTime_st *);<br>	U16 GetFisrtCluster(Type_FDTIndex uIndex);<br>	U32 GetFileLength(Type_FDTIndex uIndex);<br>};<br><br>#endif /* _MYFDT_H_ */</pre><br><pre class="brush: cpp; gutter: true">#include &quot;MyFDT.h&quot;<br><br>TCHAR *TrimRight(TCHAR *tcBuff)<br>{<br>	U32 u32Len;<br><br>	u32Len = _z_Strlen(tcBuff);<br>	for(U32 i=u32Len;i&gt;0;i--){<br>		if((U8)(tcBuff[i-1]) == &#039; &#039;){<br>			tcBuff[i-1] = &#039;/0&#039;;<br>		}<br>		else{<br>			break;<br>		}<br>	}<br><br>	return tcBuff;<br>}<br><br>CMyFDT::CMyFDT()<br>{<br>	m_IndexCnt = 0;<br>	memset(m_FDT,&#039;/0&#039;,sizeof(m_FDT));<br>}<br><br>BOOL CMyFDT::LoadFDTInfo(TCHAR u8FilePt[])<br>{<br>	TCHAR *tcCrt_p;<br>	BOOL bRet;<br><br>	bRet = TRUE;<br>	tcCrt_p = u8FilePt + FDT_START_ADDR;<br>	while(tcCrt_p[0] != &#039;/0&#039;){<br>		TCHAR tcFileBuff[9];<br>		memset(tcFileBuff,&#039;/0&#039;,sizeof(tcFileBuff));<br>		memcpy(tcFileBuff,&amp;tcCrt_p[0],8);<br>		memcpy(m_FDT[m_IndexCnt].tcFileName,TrimRight(tcFileBuff),8);<br>		memset(tcFileBuff,&#039;/0&#039;,sizeof(tcFileBuff));<br>		memcpy(tcFileBuff,&amp;tcCrt_p[8],3);<br>		memcpy(m_FDT[m_IndexCnt].tcExtName,TrimRight(tcFileBuff),3);<br>		m_FDT[m_IndexCnt].u8Ability = (TBYTE)tcCrt_p[11];<br>		memcpy(m_FDT[m_IndexCnt].u8NoUse,&amp;(tcCrt_p[12]),10);<br>		m_FDT[m_IndexCnt].u16ModifyTime = (U8)tcCrt_p[22] + ((U8)tcCrt_p[23]*0x100);<br>		m_FDT[m_IndexCnt].u16ModifyDate = (U8)tcCrt_p[24] + ((U8)tcCrt_p[25]*0x100);<br>		m_FDT[m_IndexCnt].u16FisrtCluster = (U8)tcCrt_p[26] + ((U8)tcCrt_p[27]*0x100);<br>		m_FDT[m_IndexCnt].u32FileLength = (U8)tcCrt_p[28] + ((U8)tcCrt_p[29]*0x100)+ ((U8)tcCrt_p[30]*0x10000)+ ((U8)tcCrt_p[31]*0x1000000);<br>		tcCrt_p += FDT_INFO_LENGTH;<br>		m_IndexCnt ++;<br>	}<br>	if(m_IndexCnt==0){<br>		bRet = FALSE;<br>	}<br><br>	return bRet;<br>}<br><br>Type_FDTIndex CMyFDT::GetIndexCnt()<br>{<br>	return m_IndexCnt;<br>}<br><br>TCHAR *CMyFDT::GetFileName(Type_FDTIndex uIndex,TCHAR *u8FileName_p)<br>{<br>	if(u8FileName_p!=NULL){<br>		strcpy(u8FileName_p,m_FDT[uIndex].tcFileName);<br>	}<br><br>	return m_FDT[uIndex].tcFileName;<br>}<br><br>TCHAR *CMyFDT::GetExtName(Type_FDTIndex uIndex,TCHAR *u8ExtName_p)<br>{<br>	if(u8ExtName_p!=NULL){<br>		_z_Strcpy(u8ExtName_p,(PTCHAR)m_FDT[uIndex].tcExtName);<br>	}<br><br>	return m_FDT[uIndex].tcExtName;<br>}<br><br>BOOL CMyFDT::GetFileExist(Type_FDTIndex uIndex)<br>{<br>	BOOL bRet = TRUE;<br>	if((U8)m_FDT[uIndex].tcFileName[0] == 0xE5){<br>		bRet = FALSE;<br>	}<br>	else if((U8)m_FDT[uIndex].tcFileName[0] == 0x00U){<br>		bRet = FALSE;<br>	}<br><br>	return bRet;<br>}<br><br>U8 CMyFDT::GetAbility(Type_FDTIndex uIndex)<br>{<br>	return m_FDT[uIndex].u8Ability;<br>}<br><br>void CMyFDT::GetModifyDate(Type_FDTIndex uIndex,MyDate_st *stDate_p)<br>{<br>	stDate_p-&gt;u16Year = ((m_FDT[uIndex].u16ModifyDate &amp; 0xFE00) &gt;&gt; 9) + 1980;<br>	stDate_p-&gt;u8Month = (m_FDT[uIndex].u16ModifyDate &amp; 0x01E0) &gt;&gt; 5;<br>	stDate_p-&gt;u8Day = (m_FDT[uIndex].u16ModifyDate &amp; 0x001F);<br>}<br><br>void CMyFDT::GetModifyTime(Type_FDTIndex uIndex,MyTime_st *stTime_p)<br>{<br>	stTime_p-&gt;u8Hour = ((m_FDT[uIndex].u16ModifyTime &amp; 0xF800) &gt;&gt; 11);<br>	stTime_p-&gt;u8Minute = (m_FDT[uIndex].u16ModifyTime &amp; 0x07E0) &gt;&gt; 5;<br>	stTime_p-&gt;u8Second = (m_FDT[uIndex].u16ModifyTime &amp; 0x001F);<br>}<br><br>U16 CMyFDT::GetFisrtCluster(Type_FDTIndex uIndex)<br>{<br>	return m_FDT[uIndex].u16FisrtCluster;<br>}<br><br>U32 CMyFDT::GetFileLength(Type_FDTIndex uIndex)<br>{<br>	return m_FDT[uIndex].u32FileLength;<br>}</pre><br>原文发表于：<a href="http://blog.csdn.net/zeerd">csdn.net 2009-09-26 18:46 &amp; 2009-09-27 11:18</a>