---
layout: post
title: 使用openssl进行文件或字符串的签名和认证
tag: [Linux,Openssl,Sign]
---
<!--break-->
<br><strong>sign.c</strong><br><pre class="brush: c; gutter: true">/* gcc sign.c -o sign -lcrypto */<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>#include &lt;openssl/bio.h&gt;<br>#include &lt;openssl/err.h&gt;<br>#include &lt;openssl/evp.h&gt;<br>#include &lt;openssl/objects.h&gt;<br>#include &lt;openssl/pem.h&gt;<br><br>#define _INPUT_FILE_    (0)<br><br>#undef BUFSIZE<br>#define BUFSIZE	(1024*8)<br><br>#define apps_startup() \\<br>	do { \\<br>        CRYPTO_malloc_init(); \\<br>		ERR_load_crypto_strings(); \\<br>        OpenSSL_add_all_algorithms(); \\<br>    } while(0)<br>#define apps_shutdown() \\<br>	do { \\<br>		OBJ_cleanup(); \\<br>        EVP_cleanup(); \\<br>		CRYPTO_cleanup_all_ex_data(); \\<br>        ERR_remove_thread_state(NULL); \\<br>		ERR_free_strings(); \\<br>    } while(0)<br><br>#define LOG_INIT() \\<br>    if ((bio_err=BIO_new(BIO_s_file())) != NULL) \\<br>        BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);<br>#define LOGE(args...) \\<br>    BIO_printf(bio_err, ##args);\\<br>    ERR_print_errors(bio_err);<br><br>static BIO *bio_err;<br><br>static EVP_PKEY *load_key(const char *file)<br>{<br>    BIO *key = NULL;<br>    EVP_PKEY *pkey = NULL;<br><br>    key = BIO_new(BIO_s_file());<br>    if (key != NULL) {<br>        if (BIO_read_filename(key,file) &lt;= 0) {<br>            LOGE(&quot;Error opening %s\\n&quot;, file);<br>        } else {<br>            pkey=PEM_read_bio_PrivateKey(key,NULL, NULL, NULL);<br>        }<br>    } else {<br>        LOGE(&quot;BIO_new fail&quot;);<br>    }<br><br>    if (key != NULL) BIO_free(key);<br>    return(pkey);<br>}<br><br>static int do_sign(const char *infile, BIO *bmd, const char *outfile)<br>{<br>    unsigned char *buf=NULL;<br>    size_t len = BUFSIZE;<br><br>    if ((buf=(unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL) {<br>        LOGE(&quot;out of memory\\n&quot;);<br>    } else {<br><br>#if _INPUT_FILE_<br>        BIO *in = BIO_new(BIO_s_file());<br>#else<br>        BIO *in = BIO_new_mem_buf((void*)infile, -1);<br>#endif<br>        if(in != NULL) {<br>            /* appends the BIO(in) to (bmd), it returns (bmd). */<br>            BIO *inp=BIO_push(bmd,in);<br><br>#if _INPUT_FILE_<br>            /* set the file BIO(in) to use infile for reading */<br>            if (BIO_read_filename(in,infile) &lt;= 0) {<br>                perror(infile);<br>            } else {<br>                int i = 1;<br>                while(i &gt; 0) {<br>                    /*  read BUFSIZE bytes from BIO inp <br>                        and places the data in buf. */<br>                    i = BIO_read(inp, (char *)buf, BUFSIZE);<br>                    if(i &lt; 0) {<br>                        LOGE(&quot;Read Error in input file\\n&quot;);<br>                        return 1;<br>                    }<br>                }<br>#else<br>            {<br>                BIO_read(inp, (char *)buf, BUFSIZE);<br>#endif<br><br>                EVP_MD_CTX *ctx;<br>                /* get the digest BIOs context from inp into ctx. */<br>                BIO_get_md_ctx(inp, &amp;ctx);<br>                /* signs the data in ctx, places the signature in buf. */<br>                if(EVP_DigestSignFinal(ctx, buf, &amp;len) == 0) {<br>                    LOGE(&quot;Error Signing Data\\n&quot;);<br>                    return -1;<br>                }<br><br>                BIO *out = BIO_new_file(outfile, &quot;wb&quot;);<br>                if(out == NULL) {<br>                    LOGE(&quot;Error opening output file %s\\n&quot;,<br>                        outfile);<br>                } else {<br>                    BIO_write(out, buf, len);<br>                    BIO_free_all(out);<br>                }<br>            }<br>            BIO_free(in);<br>        }<br><br>        OPENSSL_cleanse(buf,BUFSIZE);<br>        OPENSSL_free(buf);<br>    }<br><br>    return 0;<br>}<br><br>int main(int argc, char **argv)<br>{<br>    const EVP_MD *md=NULL;<br>    BIO *bmd=NULL;<br>    EVP_PKEY *sigkey = NULL;<br><br>    const char *outfile = NULL;<br>    const char *keyfile = NULL;<br>    const char *infile = NULL;<br><br>    if ( argc &lt; 4) {<br>        printf(<br>            &quot;\\nUsage:\\n\\t%s &lt;pem&gt; &lt;in&gt; &lt;out&gt;\\n&quot;<br>#if _INPUT_FILE_<br>            &quot;Example:\\n\\t%s privkey.pem foo.png foo.png.sig\\n\\n&quot;,<br>#else<br>            &quot;Example:\\n\\t%s privkey.pem \\&quot;abcdefg\\&quot; foo.sig\\n\\n&quot;,<br>#endif<br>            argv[0], argv[0]);<br>        return -1;<br>    } else {<br>        keyfile = argv[1];<br>        infile  = argv[2];<br>        outfile = argv[3];<br>    }<br><br>    apps_startup();<br><br>    LOG_INIT();<br><br>    md = EVP_sha1();<br>    if (md != NULL) {<br><br>        sigkey = load_key(keyfile);<br>        if (sigkey != NULL) {<br>            EVP_MD_CTX *mctx = NULL;<br>            <br>            /* returns the message digest BIO method. <br>            This is a filter BIO that digests any data passed through it, <br>            it is a BIO wrapper for the digest routines EVP_DigestSignInit(), <br>            and EVP_DigestSignFinal(). */<br>            bmd=BIO_new(BIO_f_md());<br>            if (bmd == NULL) {<br>                LOGE(&quot;BIO_new fail&quot;);<br>            } else {<br>                /* get the digest BIOs context from bmd into mctx. */<br>                if (!BIO_get_md_ctx(bmd, &amp;mctx)) {<br>                    LOGE(&quot;Error getting context\\n&quot;);<br>                } else {<br>                    /* sets up signing context mctx to use digest type(md) from<br>                     private key sigkey. */<br>                    int r = EVP_DigestSignInit(<br>                                mctx, NULL, md, NULL, sigkey);<br>                    if (r == 0) {<br>                        LOGE(&quot;Error setting context\\n&quot;);<br>                    } else {<br>                        do_sign(infile, bmd, outfile);<br>                    }<br>                }<br>                (void)BIO_reset(bmd);<br>                BIO_free(bmd);<br>            }<br>            EVP_PKEY_free(sigkey);<br>        } else {<br>            LOGE(&quot;unable to load key file\\n&quot;);<br>        }<br>    }<br><br>    apps_shutdown();<br><br>    return 0;<br>}<br></pre><br><br><strong>verify.c</strong><br><pre class="brush: c; gutter: true">/* gcc verify.c -o verify -lcrypto */<br><br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>#include &lt;openssl/bio.h&gt;<br>#include &lt;openssl/err.h&gt;<br>#include &lt;openssl/evp.h&gt;<br>#include &lt;openssl/objects.h&gt;<br>#include &lt;openssl/pem.h&gt;<br><br>#define _INPUT_FILE_    (0)<br><br>#undef BUFSIZE<br>#define BUFSIZE	(1024*8)<br><br>#define apps_startup() \\<br>	do { \\<br>        CRYPTO_malloc_init(); \\<br>		ERR_load_crypto_strings(); \\<br>        OpenSSL_add_all_algorithms(); \\<br>    } while(0)<br>#define apps_shutdown() \\<br>	do { \\<br>		OBJ_cleanup(); \\<br>        EVP_cleanup(); \\<br>		CRYPTO_cleanup_all_ex_data(); \\<br>        ERR_remove_thread_state(NULL); \\<br>		ERR_free_strings(); \\<br>    } while(0)<br><br>#define LOG_INIT() \\<br>    if ((bio_err=BIO_new(BIO_s_file())) != NULL) \\<br>        BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);<br>#define LOGE(args...) \\<br>    BIO_printf(bio_err, ##args);\\<br>    ERR_print_errors(bio_err);<br><br>static BIO *bio_err;<br><br>static EVP_PKEY *load_pubkey(const char *file)<br>{<br>    BIO *key=NULL;<br>    EVP_PKEY *pkey=NULL;<br><br>    key=BIO_new(BIO_s_file());<br>    if (key != NULL) {<br>        if (BIO_read_filename(key,file) &lt;= 0) {<br>            LOGE(&quot;Error opening %s\\n&quot;, file);<br>        }<br>        pkey=PEM_read_bio_PUBKEY(key,NULL, NULL, NULL);<br>    } else {<br>        LOGE(&quot;BIO_new fail&quot;);<br>    }<br><br>    if (key != NULL) BIO_free(key);<br>    return(pkey);<br>}<br><br>static int do_verify(BIO *bmd, const char* infile,<br>    unsigned char *sigin, int siglen, const char* outfile)<br>{<br>    unsigned char *buf = NULL;<br>    if ((buf=(unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL) {<br>        LOGE(&quot;out of memory\\n&quot;);<br>    } else {<br>#if _INPUT_FILE_<br>       BIO *in = BIO_new(BIO_s_file());<br>#else<br>       BIO *in = BIO_new_mem_buf((void*)infile, -1);<br>#endif<br>        if (in != NULL) {<br>            BIO *bp=BIO_push(bmd,in);<br>#if _INPUT_FILE_<br>            if (BIO_read_filename(in,infile) &lt;= 0) {<br>                perror(infile);<br>            } else {<br>                int i = 1;<br>                while(i &gt; 0) {<br>                    i=BIO_read(bp,(char *)buf,BUFSIZE);<br>                    if(i &lt; 0) {<br>                        LOGE(&quot;Read Error in input file\\n&quot;);<br>                        return 1;<br>                    }<br>                }<br>#else<br>            {<br>                BIO_read(bp, (char *)buf, BUFSIZE);<br>#endif<br><br>                if(sigin) {<br>                    EVP_MD_CTX *ctx;<br>                    BIO_get_md_ctx(bp, &amp;ctx);<br>                    int r = EVP_DigestVerifyFinal(ctx, sigin, (unsigned int)siglen);<br><br>                    BIO *out = BIO_new_file(outfile, &quot;wb&quot;);<br>                    if(out == NULL) {<br>                        LOGE(&quot;Error opening output file %s\\n&quot;,<br>                                   outfile);<br>                    } else {<br>                        if(r &gt; 0) {<br>                            BIO_printf(out, &quot;Verified OK\\n&quot;);<br>                        } else if(r == 0) {<br>                            BIO_printf(out, &quot;Verification Failure\\n&quot;);<br>                            return 1;<br>                        } else {<br>                            BIO_printf(out, &quot;Error Verifying Data\\n&quot;);<br>                            return 1;<br>                        }<br>                        BIO_free_all(out);<br>                    }<br>                }<br>            }<br>            BIO_free(in);<br>        }<br>        OPENSSL_cleanse(buf,BUFSIZE);<br>        OPENSSL_free(buf);<br>    }<br><br>    return 0;<br>}<br><br>int main(int argc, char **argv)<br>{<br>    const EVP_MD *md=NULL;<br>    BIO *bmd=NULL;<br>    EVP_PKEY *pubkey = NULL;<br>    unsigned char *sigbuf = NULL;<br>    int siglen = 0;<br><br>    const char *outfile = NULL;<br>    const char *keyfile = NULL;<br>    const char *infile = NULL;<br>    const char *sigfile = NULL;<br><br>    if ( argc &lt; 5) {<br>        printf(<br>            &quot;\\nUsage:\\n\\t%s &lt;pem&gt; &lt;sign&gt; &lt;in&gt; &lt;out&gt;\\n&quot;<br>#if _INPUT_FILE_<br>            &quot;Example:\\n\\t%s pubkey.pem foo.png.sig foo.png result.log\\n\\n&quot;,<br>#else<br>            &quot;Example:\\n\\t%s pubkey.pem foo.sig \\&quot;abcdefg\\&quot; result.log\\n\\n&quot;,<br>#endif<br>            argv[0], argv[0]);<br>        return -1;<br>    } else {<br>        keyfile = argv[1];<br>        sigfile = argv[2];<br>        infile  = argv[3];<br>        outfile = argv[4];<br>    }<br><br>    apps_startup();<br><br>    LOG_INIT();<br><br>    md = EVP_sha1();<br>    if (md == NULL) {<br>        LOGE(&quot;get sha1 digest fail\\n&quot;);<br>    } else {<br><br>        bmd=BIO_new(BIO_f_md());<br><br>        if (bmd == NULL) {<br>            LOGE(&quot;BIO_new fail&quot;);<br>        } else {<br><br>            pubkey = load_pubkey(keyfile);<br>            if (pubkey != NULL) {<br>                EVP_MD_CTX *mctx = NULL;<br><br>                if (!BIO_get_md_ctx(bmd, &amp;mctx)) {<br>                    LOGE(&quot;Error getting context\\n&quot;);<br>                } else {<br>                    int r = EVP_DigestVerifyInit(<br>                                mctx, NULL, md, NULL, pubkey);<br>                    if (r == 0) {<br>                        LOGE(&quot;Error setting context\\n&quot;);<br>                    } else {<br><br>                        siglen = EVP_PKEY_size(pubkey);<br>                        sigbuf = OPENSSL_malloc(siglen);<br>                        BIO *sigbio = BIO_new_file(sigfile, &quot;rb&quot;);<br>                        if(sigbio == NULL) {<br>                            LOGE(&quot;Error opening signature file %s\\n&quot;,<br>                                sigfile);<br>                        } else {<br>                            siglen = BIO_read(sigbio, sigbuf, siglen);<br>                            BIO_free(sigbio);<br>                            if(siglen &lt;= 0) {<br>                                LOGE(&quot;Error reading signature file %s\\n&quot;,<br>                                    sigfile);<br>                            } else {<br>                                do_verify(bmd, infile, <br>                                            sigbuf, siglen, outfile);<br>                            }<br>                        }<br>                        if (sigbuf) OPENSSL_free(sigbuf);<br>                    }<br>                }<br>                (void)BIO_reset(bmd);<br>                EVP_PKEY_free(pubkey);<br>            } else {<br>                LOGE(&quot;unable to load key file\\n&quot;);<br>            }<br>            BIO_free(bmd);<br>        }<br>    }<br><br>    apps_shutdown();<br><br>    return 0;<br>}</pre>